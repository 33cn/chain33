// Copyright Fuzamei Corp. 2018 All Rights Reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package rpc

import (
	"encoding/hex"
	"fmt"
	"testing"

	"github.com/33cn/chain33/client/mocks"
	"github.com/33cn/chain33/types"
	pb "github.com/33cn/chain33/types"
	"github.com/golang/protobuf/proto"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
	"golang.org/x/net/context"
	"google.golang.org/grpc/peer"
)

var (
	g    Grpc
	qapi *mocks.QueueProtocolAPI
)

// Addr is an autogenerated mock type for the Addr type
type Addr struct {
	mock.Mock
}

// Network provides a mock function with given fields:
func (_m *Addr) Network() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// String provides a mock function with given fields:
func (_m *Addr) String() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

func init() {
	//addr := "192.168.1.1"
	//remoteIpWhitelist[addr] = true
	//grpcFuncWhitelist["*"] = true

	qapi = new(mocks.QueueProtocolAPI)
	g.cli.QueueProtocolAPI = qapi
}

func getOkCtx() context.Context {
	addr := new(Addr)
	addr.On("String").Return("192.168.1.1")

	ctx := context.Background()
	pr := &peer.Peer{
		Addr:     addr,
		AuthInfo: nil,
	}
	ctx = peer.NewContext(ctx, pr)
	return ctx
}

//func getNokCtx() context.Context {
//	addr := new(Addr)
//	addr.On("String").Return("192.168.1.0")
//
//	ctx := context.Background()
//	pr := &peer.Peer{
//		Addr:     addr,
//		AuthInfo: nil,
//	}
//	ctx = peer.NewContext(ctx, pr)
//	return ctx
//}

func testSendTransactionOk(t *testing.T) {

	var in *types.Transaction
	reply := &types.Reply{IsOk: true, Msg: nil}
	qapi.On("SendTx", in).Return(reply, nil)

	reply, err := g.SendTransaction(getOkCtx(), in)
	assert.Nil(t, err, "the error should be nil")
	assert.Equal(t, true, reply.IsOk, "reply should be ok")
}

//func testSendTransactionReject(t *testing.T) {
//	var in *types.Transaction
//
//	_, err := g.SendTransaction(getNokCtx(), in)
//	assert.EqualError(t, err, "reject", "the error should be reject")
//}

func TestSendTransaction(t *testing.T) {
	testSendTransactionOk(t)
	//testSendTransactionReject(t)

}

//type fuc func(ctx context.Context, in)

//func testReject(t *testing.T, f func( context.Context, interface{}) (*pb.Reply, error))  {
//func testReject(t *testing.T, f func( context.Context, interface{}) (*pb.Reply, error))  {
//
//	_,err := f(getNokCtx(), nil)
//	assert.EqualError(t,err,"reject","the error should be reject")
//
//
//}

//func testVersionReject(t *testing.T) {
//	var in *pb.ReqNil
//
//	_, err := g.Version(getNokCtx(), in)
//	assert.EqualError(t, err, "reject", "the error should be reject")
//}

func testVersionOK(t *testing.T) {
	reply := &types.VersionInfo{Chain33: "6.0.2"}
	qapi.On("Version").Return(reply, nil)
	data, err := g.Version(getOkCtx(), nil)
	assert.Nil(t, err, "the error should be nil")
	assert.Equal(t, "6.0.2", data.Chain33, "reply should be ok")

}

func TestVersion(t *testing.T) {
	//testVersionReject(t)
	testVersionOK(t)
}

//func (g *Grpc) GetMemPool(ctx context.Context, in *pb.ReqNil) (*pb.ReplyTxList, error) {
//	if !g.checkWhitlist(ctx) {
//		return nil, fmt.Errorf("reject")
//	}
//	return g.cli.GetMempool()
//}

//func testGetMemPoolReject(t *testing.T) {
//	var in *pb.ReqNil
//
//	_, err := g.GetMemPool(getNokCtx(), in)
//	assert.EqualError(t, err, "reject", "the error should be reject")
//}

func testGetMemPoolOK(t *testing.T) {
	var in *types.ReqGetMempool
	qapi.On("GetMempool", in).Return(nil, nil)
	data, err := g.GetMemPool(getOkCtx(), nil)
	assert.Nil(t, err, "the error should be nil")
	assert.Nil(t, data)

}

func Test_GetMemPool(t *testing.T) {
	//testGetMemPoolReject(t)
	testGetMemPoolOK(t)
}

//func (g *Grpc) GetLastMemPool(ctx context.Context, in *pb.ReqNil) (*pb.ReplyTxList, error) {
//	if !g.checkWhitlist(ctx) {
//		return nil, fmt.Errorf("reject")
//	}
//	return g.cli.GetLastMempool()
//}

//func testGetLastMemPoolReject(t *testing.T) {
//	var in *pb.ReqNil
//
//	_, err := g.GetLastMemPool(getNokCtx(), in)
//	assert.EqualError(t, err, "reject", "the error should be reject")
//}

func testGetLastMemPoolOK(t *testing.T) {
	qapi.On("GetLastMempool").Return(nil, nil)
	data, err := g.GetLastMemPool(getOkCtx(), nil)
	assert.Nil(t, err, "the error should be nil")
	assert.Nil(t, data)

}

func TestGetLastMemPool(t *testing.T) {
	//testGetLastMemPoolReject(t)
	testGetLastMemPoolOK(t)
}

func testGetProperFeeOK(t *testing.T) {
	var in *types.ReqProperFee
	qapi.On("GetProperFee", in).Return(&types.ReplyProperFee{ProperFee: 1000000}, nil)
	data, err := g.GetProperFee(getOkCtx(), in)
	assert.Nil(t, err, "the error should be nil")
	assert.Equal(t, int64(1000000), data.ProperFee)
}

func TestGetProperFee(t *testing.T) {
	testGetProperFeeOK(t)
}

//func (g *Grpc) QueryChain(ctx context.Context, in *pb.Query) (*pb.Reply, error) {
//	if !g.checkWhitlist(ctx) {
//		return nil, fmt.Errorf("reject")
//	}
//	msg, err := g.cli.Query(in)
//	if err != nil {
//		return nil, err
//	}
//	var reply pb.Reply
//	reply.IsOk = true
//	reply.Msg = pb.Encode(*msg)
//	return &reply, nil
//}

//func testQueryChainReject(t *testing.T) {
//	_, err := g.QueryChain(getNokCtx(), nil)
//	assert.EqualError(t, err, "reject", "the error should be reject")
//}

func testQueryChainError(t *testing.T) {
	var in *pb.ChainExecutor

	qapi.On("QueryChain", in).Return(nil, fmt.Errorf("error")).Once()
	_, err := g.QueryChain(getOkCtx(), in)
	assert.EqualError(t, err, "error", "return error")
}

func testQueryChainOK(t *testing.T) {
	var in *pb.ChainExecutor
	var msg types.Message
	var req types.ReqString
	req.Data = "msg"
	msg = &req
	qapi.On("QueryChain", in).Return(msg, nil).Once()
	data, err := g.QueryChain(getOkCtx(), nil)
	assert.Nil(t, err, "the error should be nil")
	assert.Equal(t, true, data.IsOk, "reply should be ok")
	var decodemsg types.ReqString
	pb.Decode(data.Msg, &decodemsg)
	assert.Equal(t, req.Data, decodemsg.Data)
}

func TestQueryChain(t *testing.T) {
	//testQueryChainReject(t)
	testQueryChainError(t)
	testQueryChainOK(t)
}

//func testGetPeerInfoReject(t *testing.T) {
//	var in *pb.ReqNil
//
//	_, err := g.GetPeerInfo(getNokCtx(), in)
//	assert.EqualError(t, err, "reject", "the error should be reject")
//}

func testGetPeerInfoOK(t *testing.T) {
	qapi.On("PeerInfo").Return(nil, nil)
	data, err := g.GetPeerInfo(getOkCtx(), nil)
	assert.Nil(t, err, "the error should be nil")
	assert.Nil(t, data)

}

func TestGetPeerInfo(t *testing.T) {
	//testGetPeerInfoReject(t)
	testGetPeerInfoOK(t)
}

//func (g *Grpc) NetInfo(ctx context.Context, in *pb.ReqNil) (*pb.NodeNetInfo, error) {
//	if !g.checkWhitlist(ctx) {
//		return nil, fmt.Errorf("reject")
//	}
//	return g.cli.GetNetInfo()
//}

//func testNetInfoReject(t *testing.T) {
//	var in *pb.ReqNil
//
//	_, err := g.NetInfo(getNokCtx(), in)
//	assert.EqualError(t, err, "reject", "the error should be reject")
//}

func testNetInfoOK(t *testing.T) {
	qapi.On("GetNetInfo").Return(nil, nil)
	data, err := g.NetInfo(getOkCtx(), nil)
	assert.Nil(t, err, "the error should be nil")
	assert.Nil(t, data)

}

func TestNetInfo(t *testing.T) {
	//testNetInfoReject(t)
	testNetInfoOK(t)
}

//func testGetAccountsReject(t *testing.T) {
//	var in *pb.ReqNil
//
//	_, err := g.GetAccounts(getNokCtx(), in)
//	assert.EqualError(t, err, "reject", "the error should be reject")
//}

func testGetAccountsOK(t *testing.T) {
	qapi.On("WalletGetAccountList", mock.Anything).Return(nil, nil)
	data, err := g.GetAccounts(getOkCtx(), nil)
	assert.Nil(t, err, "the error should be nil")
	assert.Nil(t, data)

}

func TestGetAccounts(t *testing.T) {
	//testGetAccountsReject(t)
	testGetAccountsOK(t)
}

//func testNewAccountReject(t *testing.T) {
//	var in *pb.ReqNewAccount
//
//	_, err := g.NewAccount(getNokCtx(), in)
//	assert.EqualError(t, err, "reject", "the error should be reject")
//}

func testNewAccountOK(t *testing.T) {
	var in *pb.ReqNewAccount
	qapi.On("NewAccount", in).Return(nil, nil)
	data, err := g.NewAccount(getOkCtx(), nil)
	assert.Nil(t, err, "the error should be nil")
	assert.Nil(t, data)

}

func TestNewAccount(t *testing.T) {
	//testNewAccountReject(t)
	testNewAccountOK(t)
}

//func testWalletTransactionListReject(t *testing.T) {
//	var in *pb.ReqWalletTransactionList
//
//	_, err := g.WalletTransactionList(getNokCtx(), in)
//	assert.EqualError(t, err, "reject", "the error should be reject")
//}

func testWalletTransactionListOK(t *testing.T) {
	var in *pb.ReqWalletTransactionList
	qapi.On("WalletTransactionList", in).Return(nil, nil)
	data, err := g.WalletTransactionList(getOkCtx(), nil)
	assert.Nil(t, err, "the error should be nil")
	assert.Nil(t, data)

}

func TestWalletTransactionList(t *testing.T) {
	//testWalletTransactionListReject(t)
	testWalletTransactionListOK(t)
}

//func testImportPrivKeyReject(t *testing.T) {
//	var in *pb.ReqWalletImportPrivKey
//
//	_, err := g.ImportPrivKey(getNokCtx(), in)
//	assert.EqualError(t, err, "reject", "the error should be reject")
//}

func testImportPrivKeyOK(t *testing.T) {
	var in *pb.ReqWalletImportPrivkey
	qapi.On("WalletImportprivkey", in).Return(nil, nil)
	data, err := g.ImportPrivkey(getOkCtx(), nil)
	assert.Nil(t, err, "the error should be nil")
	assert.Nil(t, data)

}

func TestImportPrivKey(t *testing.T) {
	//testImportPrivKeyReject(t)
	testImportPrivKeyOK(t)
}

//func testSendToAddressReject(t *testing.T) {
//	var in *pb.ReqWalletSendToAddress
//
//	_, err := g.SendToAddress(getNokCtx(), in)
//	assert.EqualError(t, err, "reject", "the error should be reject")
//}

func testSendToAddressOK(t *testing.T) {
	var in *pb.ReqWalletSendToAddress
	qapi.On("WalletSendToAddress", in).Return(nil, nil)
	data, err := g.SendToAddress(getOkCtx(), nil)
	assert.Nil(t, err, "the error should be nil")
	assert.Nil(t, data)

}

func TestSendToAddress(t *testing.T) {
	//testSendToAddressReject(t)
	testSendToAddressOK(t)
}

//func testSetTxFeeReject(t *testing.T) {
//	var in *pb.ReqWalletSetFee
//
//	_, err := g.SetTxFee(getNokCtx(), in)
//	assert.EqualError(t, err, "reject", "the error should be reject")
//}

func testSetTxFeeOK(t *testing.T) {
	var in *pb.ReqWalletSetFee
	qapi.On("WalletSetFee", in).Return(nil, nil)
	data, err := g.SetTxFee(getOkCtx(), nil)
	assert.Nil(t, err, "the error should be nil")
	assert.Nil(t, data)

}

func TestSetTxFee(t *testing.T) {
	//testSetTxFeeReject(t)
	testSetTxFeeOK(t)
}

//func testSetLablReject(t *testing.T) {
//	var in *pb.ReqWalletSetLabel
//
//	_, err := g.SetLabl(getNokCtx(), in)
//	assert.EqualError(t, err, "reject", "the error should be reject")
//}

func testSetLablOK(t *testing.T) {
	var in *pb.ReqWalletSetLabel
	qapi.On("WalletSetLabel", in).Return(nil, nil)
	data, err := g.SetLabl(getOkCtx(), nil)
	assert.Nil(t, err, "the error should be nil")
	assert.Nil(t, data)

}

func TestSetLabl(t *testing.T) {
	//testSetLablReject(t)
	testSetLablOK(t)
}

//func testMergeBalanceReject(t *testing.T) {
//	var in *pb.ReqWalletMergeBalance
//
//	_, err := g.MergeBalance(getNokCtx(), in)
//	assert.EqualError(t, err, "reject", "the error should be reject")
//}

func testMergeBalanceOK(t *testing.T) {
	var in *pb.ReqWalletMergeBalance
	qapi.On("WalletMergeBalance", in).Return(nil, nil)
	data, err := g.MergeBalance(getOkCtx(), nil)
	assert.Nil(t, err, "the error should be nil")
	assert.Nil(t, data)

}

func TestMergeBalance(t *testing.T) {
	//testMergeBalanceReject(t)
	testMergeBalanceOK(t)
}

//func testSetPasswdReject(t *testing.T) {
//	var in *pb.ReqWalletSetPasswd
//
//	_, err := g.SetPasswd(getNokCtx(), in)
//	assert.EqualError(t, err, "reject", "the error should be reject")
//}

func testSetPasswdOK(t *testing.T) {
	var in *pb.ReqWalletSetPasswd
	qapi.On("WalletSetPasswd", in).Return(nil, nil)
	data, err := g.SetPasswd(getOkCtx(), nil)
	assert.Nil(t, err, "the error should be nil")
	assert.Nil(t, data)

}

func TestSetPasswd(t *testing.T) {
	//testSetPasswdReject(t)
	testSetPasswdOK(t)
}

//func testLockReject(t *testing.T) {
//	var in *pb.ReqNil
//
//	_, err := g.Lock(getNokCtx(), in)
//	assert.EqualError(t, err, "reject", "the error should be reject")
//}

func testLockOK(t *testing.T) {

	qapi.On("WalletLock").Return(nil, nil)
	data, err := g.Lock(getOkCtx(), nil)
	assert.Nil(t, err, "the error should be nil")
	assert.Nil(t, data)

}

func TestLock(t *testing.T) {
	//testLockReject(t)
	testLockOK(t)
}

//func testUnLockReject(t *testing.T) {
//	var in *pb.WalletUnLock
//
//	_, err := g.UnLock(getNokCtx(), in)
//	assert.EqualError(t, err, "reject", "the error should be reject")
//}

func testUnLockOK(t *testing.T) {
	var in *pb.WalletUnLock
	qapi.On("WalletUnLock", in).Return(nil, nil)
	data, err := g.UnLock(getOkCtx(), nil)
	assert.Nil(t, err, "the error should be nil")
	assert.Nil(t, data)

}

func TestUnLock(t *testing.T) {
	//testUnLockReject(t)
	testUnLockOK(t)
}

//func testGenSeedReject(t *testing.T) {
//	var in *pb.GenSeedLang
//
//	_, err := g.GenSeed(getNokCtx(), in)
//	assert.EqualError(t, err, "reject", "the error should be reject")
//}

func testGenSeedOK(t *testing.T) {
	var in *pb.GenSeedLang
	qapi.On("GenSeed", in).Return(nil, nil)
	data, err := g.GenSeed(getOkCtx(), nil)
	assert.Nil(t, err, "the error should be nil")
	assert.Nil(t, data)

}

func TestGenSeed(t *testing.T) {
	//testGenSeedReject(t)
	testGenSeedOK(t)
}

//func testGetSeedReject(t *testing.T) {
//	var in *pb.GetSeedByPw
//
//	_, err := g.GetSeed(getNokCtx(), in)
//	assert.EqualError(t, err, "reject", "the error should be reject")
//}

func testGetSeedOK(t *testing.T) {
	var in *pb.GetSeedByPw
	qapi.On("GetSeed", in).Return(nil, nil)
	data, err := g.GetSeed(getOkCtx(), nil)
	assert.Nil(t, err, "the error should be nil")
	assert.Nil(t, data)

}

func TestGetSeed(t *testing.T) {
	//testGetSeedReject(t)
	testGetSeedOK(t)
}

//func testSaveSeedReject(t *testing.T) {
//	var in *pb.SaveSeedByPw
//
//	_, err := g.SaveSeed(getNokCtx(), in)
//	assert.EqualError(t, err, "reject", "the error should be reject")
//}

func testSaveSeedOK(t *testing.T) {
	var in *pb.SaveSeedByPw
	qapi.On("SaveSeed", in).Return(nil, nil)
	data, err := g.SaveSeed(getOkCtx(), nil)
	assert.Nil(t, err, "the error should be nil")
	assert.Nil(t, data)

}

func TestSaveSeed(t *testing.T) {
	//testSaveSeedReject(t)
	testSaveSeedOK(t)
}

//func testGetWalletStatusReject(t *testing.T) {
//	var in *pb.ReqNil
//
//	_, err := g.GetWalletStatus(getNokCtx(), in)
//	assert.EqualError(t, err, "reject", "the error should be reject")
//}

func testGetWalletStatusOK(t *testing.T) {
	qapi.On("GetWalletStatus").Return(nil, nil)
	data, err := g.GetWalletStatus(getOkCtx(), nil)
	assert.Nil(t, err, "the error should be nil")
	assert.Nil(t, data)

}

func TestGetWalletStatus(t *testing.T) {
	//testGetWalletStatusReject(t)
	testGetWalletStatusOK(t)
}

//func testSetAutoMiningReject(t *testing.T) {
//	var in *pb.MinerFlag
//
//	_, err := g.SetAutoMining(getNokCtx(), in)
//	assert.EqualError(t, err, "reject", "the error should be reject")
//}

//func testDumpPrivkeyReject(t *testing.T) {
//	var in *pb.ReqStr
//
//	_, err := g.DumpPrivkey(getNokCtx(), in)
//	assert.EqualError(t, err, "reject", "the error should be reject")
//}

func testDumpPrivkeyOK(t *testing.T) {
	var in *pb.ReqString
	qapi.On("DumpPrivkey", in).Return(nil, nil)
	data, err := g.DumpPrivkey(getOkCtx(), nil)
	assert.Nil(t, err, "the error should be nil")
	assert.Nil(t, data)

}

func TestDumpPrivkey(t *testing.T) {
	//testDumpPrivkeyReject(t)
	testDumpPrivkeyOK(t)
}

//func testCloseTicketsReject(t *testing.T) {
//	var in *pb.ReqNil
//
//	_, err := g.CloseTickets(getNokCtx(), in)
//	assert.EqualError(t, err, "reject", "the error should be reject")
//}

//func testGetBlocksReject(t *testing.T) {
//	var in *pb.ReqBlocks
//
//	_, err := g.GetBlocks(getNokCtx(), in)
//	assert.EqualError(t, err, "reject", "the error should be reject")
//}

func testGetBlocksError(t *testing.T) {
	var in = pb.ReqBlocks{IsDetail: true}

	qapi.On("GetBlocks", &in).Return(nil, fmt.Errorf("error")).Once()
	_, err := g.GetBlocks(getOkCtx(), &in)
	assert.EqualError(t, err, "error", "the error should be error")

}

func testGetBlocksOK(t *testing.T) {
	var in = pb.ReqBlocks{IsDetail: true}
	var details types.BlockDetails

	var block = &types.Block{Version: 1}
	var detail = &types.BlockDetail{Block: block}
	details.Items = append(details.Items, detail)

	qapi.On("GetBlocks", &in).Return(&details, nil).Once()
	data, err := g.GetBlocks(getOkCtx(), &in)
	assert.Nil(t, err, "the error should be nil")
	assert.Equal(t, true, data.IsOk)

	var details2 types.BlockDetails
	pb.Decode(data.Msg, &details2)
	if !proto.Equal(&details, &details2) {
		assert.Equal(t, details, details2)
	}
}

func TestGetBlocks(t *testing.T) {
	//testGetBlocksReject(t)
	testGetBlocksError(t)
	testGetBlocksOK(t)
}

//func (g *Grpc) GetHexTxByHash(ctx context.Context, in *pb.ReqHash) (*pb.HexTx, error) {
//	if !g.checkWhitlist(ctx) {
//		return nil, fmt.Errorf("reject")
//	}
//	reply, err := g.cli.QueryTx(in)
//	if err != nil {
//		return nil, err
//	}
//	tx := reply.GetTx()
//	if tx == nil {
//		return &pb.HexTx{}, nil
//	}
//	return &pb.HexTx{Tx: hex.EncodeToString(pb.Encode(reply.GetTx()))}, nil
//}
//func testGetHexTxByHashReject(t *testing.T) {
//	var in *pb.ReqHash
//
//	_, err := g.GetHexTxByHash(getNokCtx(), in)
//	assert.EqualError(t, err, "reject", "the error should be reject")
//}

func testGetHexTxByHashError(t *testing.T) {
	var in *pb.ReqHash

	qapi.On("QueryTx", in).Return(nil, fmt.Errorf("error")).Once()
	_, err := g.GetHexTxByHash(getOkCtx(), in)
	assert.EqualError(t, err, "error", "the error should be error")
}

func testGetHexTxByHashOK(t *testing.T) {
	var in *pb.ReqHash
	tx := &types.Transaction{Fee: 1}
	var td = &types.TransactionDetail{Tx: tx}
	var tdNil = &types.TransactionDetail{Tx: nil}

	encodetx := hex.EncodeToString(pb.Encode(tx))

	qapi.On("QueryTx", in).Return(tdNil, nil).Once()
	data, err := g.GetHexTxByHash(getOkCtx(), in)
	assert.Nil(t, err, "the error should be nil")
	assert.Equal(t, "", data.Tx)

	qapi.On("QueryTx", in).Return(td, nil).Once()
	data, err = g.GetHexTxByHash(getOkCtx(), in)
	assert.Nil(t, err, "the error should be nil")
	assert.Equal(t, encodetx, data.Tx)

}

func TestGetHexTxByHash(t *testing.T) {
	//testGetHexTxByHashReject(t)
	testGetHexTxByHashError(t)
	testGetHexTxByHashOK(t)
}

//func testGetTransactionByAddrReject(t *testing.T) {
//	var in *pb.ReqAddr
//
//	_, err := g.GetTransactionByAddr(getNokCtx(), in)
//	assert.EqualError(t, err, "reject", "the error should be reject")
//}

func testGetTransactionByAddrOK(t *testing.T) {
	var in *pb.ReqAddr
	qapi.On("GetTransactionByAddr", in).Return(nil, nil)
	data, err := g.GetTransactionByAddr(getOkCtx(), in)
	assert.Nil(t, err, "the error should be nil")
	assert.Nil(t, data)

}

func TestGetTransactionByAddr(t *testing.T) {
	//testGetTransactionByAddrReject(t)
	testGetTransactionByAddrOK(t)
}

//func testGetTransactionByHashesReject(t *testing.T) {
//	var in *pb.ReqHashes
//
//	_, err := g.GetTransactionByHashes(getNokCtx(), in)
//	assert.EqualError(t, err, "reject", "the error should be reject")
//}

func testGetTransactionByHashesOK(t *testing.T) {
	var in *pb.ReqHashes
	qapi.On("GetTransactionByHash", in).Return(nil, nil)
	data, err := g.GetTransactionByHashes(getOkCtx(), in)
	assert.Nil(t, err, "the error should be nil")
	assert.Nil(t, data)

}

func TestGetTransactionByHashes(t *testing.T) {
	//testGetTransactionByHashesReject(t)
	testGetTransactionByHashesOK(t)
}

//func testGetHeadersReject(t *testing.T) {
//	var in *pb.ReqBlocks
//
//	_, err := g.GetHeaders(getNokCtx(), in)
//	assert.EqualError(t, err, "reject", "the error should be reject")
//}

func testGetHeadersOK(t *testing.T) {
	var in *pb.ReqBlocks
	qapi.On("GetHeaders", in).Return(nil, nil)
	data, err := g.GetHeaders(getOkCtx(), in)
	assert.Nil(t, err, "the error should be nil")
	assert.Nil(t, data)

}

func TestGetHeaders(t *testing.T) {
	//testGetHeadersReject(t)
	testGetHeadersOK(t)
}

//func testGetBlockOverviewReject(t *testing.T) {
//	var in *pb.ReqHash
//
//	_, err := g.GetBlockOverview(getNokCtx(), in)
//	assert.EqualError(t, err, "reject", "the error should be reject")
//}

func testGetBlockOverviewOK(t *testing.T) {
	var in *pb.ReqHash
	qapi.On("GetBlockOverview", in).Return(nil, nil)
	data, err := g.GetBlockOverview(getOkCtx(), in)
	assert.Nil(t, err, "the error should be nil")
	assert.Nil(t, data)

}

func TestGetBlockOverview(t *testing.T) {
	//testGetBlockOverviewReject(t)
	testGetBlockOverviewOK(t)
}

//func (g *Grpc) GetAddrOverview(ctx context.Context, in *pb.ReqAddr) (*pb.AddrOverview, error) {
//	if !g.checkWhitlist(ctx) {
//		return nil, fmt.Errorf("reject")
//	}
//	return g.cli.GetAddrOverview(in)
//}

//func testGetAddrOverviewReject(t *testing.T) {
//	var in *pb.ReqAddr
//
//	_, err := g.GetAddrOverview(getNokCtx(), in)
//	assert.EqualError(t, err, "reject", "the error should be reject")
//}

//client implement self GetAddrOverview instead of api interface
//func testGetAddrOverviewOK(t *testing.T) {
//	var in *pb.ReqAddr
//	qapi.On("GetAddrOverview", in).Return(nil, nil)
//	data, err := g.GetAddrOverview(getOkCtx(), in)
//	assert.Nil(t, err, "the error should be nil")
//	assert.Nil(t, data)
//
//}

//func TestGetAddrOverview(t *testing.T) {
//	//testGetAddrOverviewReject(t)
//	testGetAddrOverviewOK(t)
//}

//func (g *Grpc) GetBlockHash(ctx context.Context, in *pb.ReqInt) (*pb.ReplyHash, error) {
//	if !g.checkWhitlist(ctx) {
//		return nil, fmt.Errorf("reject")
//	}
//	return g.cli.GetBlockHash(in)
//}
//func testGetBlockHashReject(t *testing.T) {
//	var in *pb.ReqInt
//
//	_, err := g.GetBlockHash(getNokCtx(), in)
//	assert.EqualError(t, err, "reject", "the error should be reject")
//}

func testGetBlockHashOK(t *testing.T) {
	var in *pb.ReqInt
	qapi.On("GetBlockHash", in).Return(nil, nil)
	data, err := g.GetBlockHash(getOkCtx(), in)
	assert.Nil(t, err, "the error should be nil")
	assert.Nil(t, data)

}

func TestGetBlockHash(t *testing.T) {
	//testGetBlockHashReject(t)
	testGetBlockHashOK(t)
}

//func testIsSyncReject(t *testing.T) {
//	var in *pb.ReqNil
//
//	_, err := g.IsSync(getNokCtx(), in)
//	assert.EqualError(t, err, "reject", "the error should be reject")
//}

func testIsSyncOK(t *testing.T) {
	var in *pb.ReqNil
	qapi.On("IsSync").Return(nil, nil)
	data, err := g.IsSync(getOkCtx(), in)
	assert.Nil(t, err, "the error should be nil")
	assert.Nil(t, data)

}

func TestIsSync(t *testing.T) {
	//testIsSyncReject(t)
	testIsSyncOK(t)
}

//func testIsNtpClockSyncReject(t *testing.T) {
//	var in *pb.ReqNil
//
//	_, err := g.IsNtpClockSync(getNokCtx(), in)
//	assert.EqualError(t, err, "reject", "the error should be reject")
//}

func testIsNtpClockSyncOK(t *testing.T) {
	var in *pb.ReqNil
	qapi.On("IsNtpClockSync").Return(nil, nil)
	data, err := g.IsNtpClockSync(getOkCtx(), in)
	assert.Nil(t, err, "the error should be nil")
	assert.Nil(t, data)

}

func TestIsNtpClockSync(t *testing.T) {
	//testIsNtpClockSyncReject(t)
	testIsNtpClockSyncOK(t)
}

//func testGetLastHeaderReject(t *testing.T) {
//	var in *pb.ReqNil
//
//	_, err := g.GetLastHeader(getNokCtx(), in)
//	assert.EqualError(t, err, "reject", "the error should be reject")
//}

func testGetLastHeaderOK(t *testing.T) {
	var in *pb.ReqNil
	qapi.On("GetLastHeader").Return(nil, nil)
	data, err := g.GetLastHeader(getOkCtx(), in)
	assert.Nil(t, err, "the error should be nil")
	assert.Nil(t, data)

}

func TestGetLastHeader(t *testing.T) {
	//testGetLastHeaderReject(t)
	testGetLastHeaderOK(t)
}

//func testCreateRawTransactionReject(t *testing.T) {
//	var in *pb.CreateTx
//
//	_, err := g.CreateRawTransaction(getNokCtx(), in)
//	assert.EqualError(t, err, "reject", "the erros should be reject")
//}

//func testCreateRawTransactionError(t *testing.T)  {
//	var in *pb.CreateTx
//
//	qapi.On("CreateRawTransaction", in).Return(nil, fmt.Errorf("rejj"))
//	_,err := g.CreateRawTransaction(getOkCtx(), in)
//	assert.EqualError(t,err,"error","return error")
//}

//func testCreateRawTransactionOk(t *testing.T)  {
//	var in *pb.CreateTx
//	reply := []byte("reply")
//
//
//	qapi.On("CreateRawTransaction", in).Return(reply, nil)
//	data,_ := g.CreateRawTransaction(getOkCtx(), in)
//	assert.Equal(t,reply,data.Data,"return correct reply data")
//}
//
//func Test_CreateRawTransaction(t *testing.T) {
//	//testCreateRawTransactionReject(t)
//	testCreateRawTransactionError(t)
//	testCreateRawTransactionOk(t)
//}

//func testQueryTransactionReject(t *testing.T) {
//	var in *pb.ReqHash
//
//	_, err := g.QueryTransaction(getNokCtx(), in)
//	assert.EqualError(t, err, "reject", "the erros should be reject")
//}
func testQueryTransactionOK(t *testing.T) {
	var in *pb.ReqHash
	qapi.On("QueryTx", in).Return(nil, nil)
	data, err := g.QueryTransaction(getOkCtx(), in)
	assert.Nil(t, err, "the error should be nil")
	assert.Nil(t, data)

}

func TestQueryTransaction(t *testing.T) {
	//testQueryTransactionReject(t)
	testQueryTransactionOK(t)
}

//func testGetBalanceReject(t *testing.T) {
//	var in *pb.ReqBalance
//
//	_, err := g.GetBalance(getNokCtx(), in)
//	assert.EqualError(t, err, "reject", "the erros should be reject")
//}

//func TestGetBalance(t *testing.T) {
//	testGetBalanceReject(t)
//}

//func testGetTokenBalanceReject(t *testing.T) {
//	var in *pb.ReqTokenBalance
//
//	_, err := g.GetTokenBalance(getNokCtx(), in)
//	assert.EqualError(t, err, "reject", "the erros should be reject")
//}

//func TestGetTokenBalance(t *testing.T) {
//	testGetTokenBalanceReject(t)
//}

//func testCreateTxGroupOk(t *testing.T) {
//	txHex1 := "0a05636f696e73122c18010a281080c2d72f222131477444795771577233553637656a7663776d333867396e7a6e7a434b58434b7120a08d0630a696c0b3f78dd9ec083a2131477444795771577233553637656a7663776d333867396e7a6e7a434b58434b71"
//	txHex2 := "0a05636f696e73122d18010a29108084af5f222231484c53426e7437486e486a7857797a636a6f573863663259745550663337594d6320a08d0630dbc4cbf6fbc4e1d0533a2231484c53426e7437486e486a7857797a636a6f573863663259745550663337594d63"
//	txs := &types.CreateTransactionGroup{
//		Txs: []string{txHex1, txHex2},
//	}

//	reply := []byte("reply")

//	qapi.On("CreateRawTxGroup", txs).Return(reply, nil)
//	data, _ := g.CreateRawTxGroup(getOkCtx(), txs)
//	assert.Equal(t, reply, data.Data, "return correct reply data")
//}

//func Test_CreateTxGroup(t *testing.T) {
//	testCreateTxGroupOk(t)
//}

func TestReWriteRawTx(t *testing.T) {
	txHex1 := "0a05636f696e73122c18010a281080c2d72f222131477444795771577233553637656a7663776d333867396e7a6e7a434b58434b7120a08d0630a696c0b3f78dd9ec083a2131477444795771577233553637656a7663776d333867396e7a6e7a434b58434b71"
	in := &types.ReWriteRawTx{
		Tx:     txHex1,
		Fee:    29977777777,
		Expire: "130s",
		To:     "aabbccdd",
		Index:  0,
	}

	data, err := g.ReWriteRawTx(getOkCtx(), in)
	assert.Nil(t, err)
	assert.NotNil(t, data.Data)
	rtTx := hex.EncodeToString(data.Data)
	assert.NotEqual(t, txHex1, rtTx)

	tx := &types.Transaction{}
	err = types.Decode(data.Data, tx)
	assert.Nil(t, err)
	assert.Equal(t, tx.Fee, in.Fee)
	assert.Equal(t, in.To, tx.To)
}

func TestGrpc_CreateNoBalanceTransaction(t *testing.T) {
	_, err := g.CreateNoBalanceTransaction(getOkCtx(), &pb.NoBalanceTx{})
	assert.NoError(t, err)
}

func TestGrpc_CreateNoBalanceTxs(t *testing.T) {
	_, err := g.CreateNoBalanceTxs(getOkCtx(), &pb.NoBalanceTxs{TxHexs: []string{"0a05746f6b656e12413804223d0a0443434e5910a09c011a0d74657374207472616e73666572222231333559774e715367694551787577586650626d526d48325935334564673864343820a08d0630969a9fe6c4b9c7ba5d3a2231333559774e715367694551787577586650626d526d483259353345646738643438", "0a05746f6b656e12413804223d0a0443434e5910b0ea011a0d74657374207472616e73666572222231333559774e715367694551787577586650626d526d48325935334564673864343820a08d0630bca0a2dbc0f182e06f3a2231333559774e715367694551787577586650626d526d483259353345646738643438"}})
	assert.NoError(t, err)
}

func TestGrpc_CreateRawTransaction(t *testing.T) {
	_, err := g.CreateRawTransaction(getOkCtx(), &pb.CreateTx{})
	assert.NoError(t, err)
}

func TestGrpc_CreateTransaction(t *testing.T) {
	_, err := g.CreateTransaction(getOkCtx(), &pb.CreateTxIn{Execer: []byte("coins")})
	assert.Equal(t, err, types.ErrActionNotSupport)
}

func TestGrpc_CreateRawTxGroup(t *testing.T) {
	_, err := g.CreateRawTxGroup(getOkCtx(), &pb.CreateTransactionGroup{})
	assert.Equal(t, types.ErrTxGroupCountLessThanTwo, err)
}

func TestGrpc_GetAddrOverview(t *testing.T) {
	_, err := g.GetAddrOverview(getOkCtx(), &types.ReqAddr{})
	assert.Equal(t, err, types.ErrInvalidAddress)
}

func TestGrpc_GetBalance(t *testing.T) {
	qapi.On("StoreGet", mock.Anything).Return(nil, types.ErrInvalidParam)
	_, err := g.GetBalance(getOkCtx(), &types.ReqBalance{})
	assert.Equal(t, err, types.ErrInvalidParam)
}

func TestGrpc_GetAllExecBalance(t *testing.T) {
	_, err := g.GetAllExecBalance(getOkCtx(), &pb.ReqAllExecBalance{})
	assert.Equal(t, err, types.ErrInvalidAddress)
}

func TestGrpc_QueryConsensus(t *testing.T) {
	qapi.On("QueryConsensus", mock.Anything).Return(&types.ReqString{Data: "test"}, nil)
	_, err := g.QueryConsensus(getOkCtx(), &pb.ChainExecutor{})
	assert.NoError(t, err)
}

func TestGrpc_ExecWallet(t *testing.T) {
	qapi.On("ExecWallet", mock.Anything).Return(&types.ReqString{Data: "test"}, nil)
	_, err := g.ExecWallet(getOkCtx(), &pb.ChainExecutor{})
	assert.NoError(t, err)
}

func TestGrpc_GetLastBlockSequence(t *testing.T) {
	qapi.On("GetLastBlockSequence", mock.Anything).Return(nil, nil)
	_, err := g.GetLastBlockSequence(getOkCtx(), &types.ReqNil{})
	assert.NoError(t, err)
}

func TestGrpc_GetBlockByHashes(t *testing.T) {
	qapi.On("GetBlockByHashes", mock.Anything, mock.Anything, mock.Anything).Return(nil, nil)
	_, err := g.GetBlockByHashes(getOkCtx(), &types.ReqHashes{})
	assert.NoError(t, err)
}

func TestGrpc_GetSequenceByHash(t *testing.T) {
	qapi.On("GetSequenceByHash", mock.Anything, mock.Anything, mock.Anything).Return(nil, nil)
	_, err := g.GetSequenceByHash(getOkCtx(), &pb.ReqHash{})
	assert.NoError(t, err)
}

func TestGrpc_SignRawTx(t *testing.T) {
	qapi.On("SignRawTx", mock.Anything, mock.Anything, mock.Anything).Return(nil, nil)
	_, err := g.SignRawTx(getOkCtx(), &types.ReqSignRawTx{})
	assert.NoError(t, err)
}

func TestGrpc_QueryRandNum(t *testing.T) {
	qapi.On("Query", mock.Anything, mock.Anything, mock.Anything).Return(&pb.ReplyHash{Hash: []byte("test")}, nil)
	_, err := g.QueryRandNum(getOkCtx(), &pb.ReqRandHash{})
	assert.NoError(t, err)
}

func TestGrpc_GetFork(t *testing.T) {
	pb.SetDappFork("local", "para", "fork100", 100)
	val, err := g.GetFork(getOkCtx(), &pb.ReqKey{Key: []byte("para-fork100")})
	assert.NoError(t, err)
	assert.Equal(t, int64(100), val.Data)

	val, err = g.GetFork(getOkCtx(), &pb.ReqKey{Key: []byte("ForkBlockHash")})
	assert.NoError(t, err)
	assert.Equal(t, int64(1), val.Data)
}
