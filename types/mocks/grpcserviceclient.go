// Code generated by mockery v1.0.0. DO NOT EDIT.
package mocks

import context "context"
import grpc "google.golang.org/grpc"
import mock "github.com/stretchr/testify/mock"
import types "gitlab.33.cn/chain33/chain33/types"

// GrpcserviceClient is an autogenerated mock type for the GrpcserviceClient type
type GrpcserviceClient struct {
	mock.Mock
}

// CloseQueue provides a mock function with given fields: ctx, in, opts
func (_m *GrpcserviceClient) CloseQueue(ctx context.Context, in *types.ReqNil, opts ...grpc.CallOption) (*types.Reply, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *types.Reply
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqNil, ...grpc.CallOption) *types.Reply); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Reply)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqNil, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateBindMiner provides a mock function with given fields: ctx, in, opts
func (_m *GrpcserviceClient) CreateBindMiner(ctx context.Context, in *types.ReqBindMiner, opts ...grpc.CallOption) (*types.ReplyBindMiner, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *types.ReplyBindMiner
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqBindMiner, ...grpc.CallOption) *types.ReplyBindMiner); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.ReplyBindMiner)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqBindMiner, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateNoBalanceTransaction provides a mock function with given fields: ctx, in, opts
func (_m *GrpcserviceClient) CreateNoBalanceTransaction(ctx context.Context, in *types.NoBalanceTx, opts ...grpc.CallOption) (*types.ReplySignRawTx, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *types.ReplySignRawTx
	if rf, ok := ret.Get(0).(func(context.Context, *types.NoBalanceTx, ...grpc.CallOption) *types.ReplySignRawTx); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.ReplySignRawTx)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.NoBalanceTx, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateRawTransaction provides a mock function with given fields: ctx, in, opts
func (_m *GrpcserviceClient) CreateRawTransaction(ctx context.Context, in *types.CreateTx, opts ...grpc.CallOption) (*types.UnsignTx, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *types.UnsignTx
	if rf, ok := ret.Get(0).(func(context.Context, *types.CreateTx, ...grpc.CallOption) *types.UnsignTx); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.UnsignTx)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.CreateTx, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateUTXOs provides a mock function with given fields: ctx, in, opts
func (_m *GrpcserviceClient) CreateUTXOs(ctx context.Context, in *types.ReqCreateUTXOs, opts ...grpc.CallOption) (*types.Reply, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *types.Reply
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqCreateUTXOs, ...grpc.CallOption) *types.Reply); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Reply)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqCreateUTXOs, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DumpPrivkey provides a mock function with given fields: ctx, in, opts
func (_m *GrpcserviceClient) DumpPrivkey(ctx context.Context, in *types.ReqStr, opts ...grpc.CallOption) (*types.ReplyStr, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *types.ReplyStr
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqStr, ...grpc.CallOption) *types.ReplyStr); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.ReplyStr)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqStr, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GenSeed provides a mock function with given fields: ctx, in, opts
func (_m *GrpcserviceClient) GenSeed(ctx context.Context, in *types.GenSeedLang, opts ...grpc.CallOption) (*types.ReplySeed, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *types.ReplySeed
	if rf, ok := ret.Get(0).(func(context.Context, *types.GenSeedLang, ...grpc.CallOption) *types.ReplySeed); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.ReplySeed)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.GenSeedLang, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAccounts provides a mock function with given fields: ctx, in, opts
func (_m *GrpcserviceClient) GetAccounts(ctx context.Context, in *types.ReqNil, opts ...grpc.CallOption) (*types.WalletAccounts, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *types.WalletAccounts
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqNil, ...grpc.CallOption) *types.WalletAccounts); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.WalletAccounts)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqNil, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAddrOverview provides a mock function with given fields: ctx, in, opts
func (_m *GrpcserviceClient) GetAddrOverview(ctx context.Context, in *types.ReqAddr, opts ...grpc.CallOption) (*types.AddrOverview, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *types.AddrOverview
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqAddr, ...grpc.CallOption) *types.AddrOverview); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.AddrOverview)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqAddr, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAllExecBalance provides a mock function with given fields: ctx, in, opts
func (_m *GrpcserviceClient) GetAllExecBalance(ctx context.Context, in *types.ReqAddr, opts ...grpc.CallOption) (*types.AllExecBalance, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *types.AllExecBalance
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqAddr, ...grpc.CallOption) *types.AllExecBalance); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.AllExecBalance)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqAddr, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBalance provides a mock function with given fields: ctx, in, opts
func (_m *GrpcserviceClient) GetBalance(ctx context.Context, in *types.ReqBalance, opts ...grpc.CallOption) (*types.Accounts, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *types.Accounts
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqBalance, ...grpc.CallOption) *types.Accounts); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Accounts)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqBalance, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBlockByHashes provides a mock function with given fields: ctx, in, opts
func (_m *GrpcserviceClient) GetBlockByHashes(ctx context.Context, in *types.ReqHashes, opts ...grpc.CallOption) (*types.BlockDetails, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *types.BlockDetails
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqHashes, ...grpc.CallOption) *types.BlockDetails); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.BlockDetails)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqHashes, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBlockHash provides a mock function with given fields: ctx, in, opts
func (_m *GrpcserviceClient) GetBlockHash(ctx context.Context, in *types.ReqInt, opts ...grpc.CallOption) (*types.ReplyHash, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *types.ReplyHash
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqInt, ...grpc.CallOption) *types.ReplyHash); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.ReplyHash)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqInt, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBlockOverview provides a mock function with given fields: ctx, in, opts
func (_m *GrpcserviceClient) GetBlockOverview(ctx context.Context, in *types.ReqHash, opts ...grpc.CallOption) (*types.BlockOverview, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *types.BlockOverview
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqHash, ...grpc.CallOption) *types.BlockOverview); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.BlockOverview)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqHash, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBlockSequences provides a mock function with given fields: ctx, in, opts
func (_m *GrpcserviceClient) GetBlockSequences(ctx context.Context, in *types.ReqBlocks, opts ...grpc.CallOption) (*types.BlockSequences, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *types.BlockSequences
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqBlocks, ...grpc.CallOption) *types.BlockSequences); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.BlockSequences)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqBlocks, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBlocks provides a mock function with given fields: ctx, in, opts
func (_m *GrpcserviceClient) GetBlocks(ctx context.Context, in *types.ReqBlocks, opts ...grpc.CallOption) (*types.Reply, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *types.Reply
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqBlocks, ...grpc.CallOption) *types.Reply); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Reply)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqBlocks, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetFatalFailure provides a mock function with given fields: ctx, in, opts
func (_m *GrpcserviceClient) GetFatalFailure(ctx context.Context, in *types.ReqNil, opts ...grpc.CallOption) (*types.Int32, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *types.Int32
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqNil, ...grpc.CallOption) *types.Int32); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Int32)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqNil, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetHexTxByHash provides a mock function with given fields: ctx, in, opts
func (_m *GrpcserviceClient) GetHexTxByHash(ctx context.Context, in *types.ReqHash, opts ...grpc.CallOption) (*types.HexTx, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *types.HexTx
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqHash, ...grpc.CallOption) *types.HexTx); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.HexTx)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqHash, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetLastBlockSequence provides a mock function with given fields: ctx, in, opts
func (_m *GrpcserviceClient) GetLastBlockSequence(ctx context.Context, in *types.ReqNil, opts ...grpc.CallOption) (*types.Int64, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *types.Int64
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqNil, ...grpc.CallOption) *types.Int64); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Int64)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqNil, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetLastHeader provides a mock function with given fields: ctx, in, opts
func (_m *GrpcserviceClient) GetLastHeader(ctx context.Context, in *types.ReqNil, opts ...grpc.CallOption) (*types.Header, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *types.Header
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqNil, ...grpc.CallOption) *types.Header); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Header)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqNil, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetLastMemPool provides a mock function with given fields: ctx, in, opts
func (_m *GrpcserviceClient) GetLastMemPool(ctx context.Context, in *types.ReqNil, opts ...grpc.CallOption) (*types.ReplyTxList, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *types.ReplyTxList
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqNil, ...grpc.CallOption) *types.ReplyTxList); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.ReplyTxList)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqNil, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetMemPool provides a mock function with given fields: ctx, in, opts
func (_m *GrpcserviceClient) GetMemPool(ctx context.Context, in *types.ReqNil, opts ...grpc.CallOption) (*types.ReplyTxList, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *types.ReplyTxList
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqNil, ...grpc.CallOption) *types.ReplyTxList); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.ReplyTxList)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqNil, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetPeerInfo provides a mock function with given fields: ctx, in, opts
func (_m *GrpcserviceClient) GetPeerInfo(ctx context.Context, in *types.ReqNil, opts ...grpc.CallOption) (*types.PeerList, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *types.PeerList
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqNil, ...grpc.CallOption) *types.PeerList); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.PeerList)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqNil, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetSeed provides a mock function with given fields: ctx, in, opts
func (_m *GrpcserviceClient) GetSeed(ctx context.Context, in *types.GetSeedByPw, opts ...grpc.CallOption) (*types.ReplySeed, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *types.ReplySeed
	if rf, ok := ret.Get(0).(func(context.Context, *types.GetSeedByPw, ...grpc.CallOption) *types.ReplySeed); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.ReplySeed)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.GetSeedByPw, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTicketCount provides a mock function with given fields: ctx, in, opts
func (_m *GrpcserviceClient) GetTicketCount(ctx context.Context, in *types.ReqNil, opts ...grpc.CallOption) (*types.Int64, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *types.Int64
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqNil, ...grpc.CallOption) *types.Int64); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Int64)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqNil, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTransactionByAddr provides a mock function with given fields: ctx, in, opts
func (_m *GrpcserviceClient) GetTransactionByAddr(ctx context.Context, in *types.ReqAddr, opts ...grpc.CallOption) (*types.ReplyTxInfos, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *types.ReplyTxInfos
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqAddr, ...grpc.CallOption) *types.ReplyTxInfos); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.ReplyTxInfos)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqAddr, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTransactionByHashes provides a mock function with given fields: ctx, in, opts
func (_m *GrpcserviceClient) GetTransactionByHashes(ctx context.Context, in *types.ReqHashes, opts ...grpc.CallOption) (*types.TransactionDetails, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *types.TransactionDetails
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqHashes, ...grpc.CallOption) *types.TransactionDetails); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.TransactionDetails)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqHashes, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetWalletStatus provides a mock function with given fields: ctx, in, opts
func (_m *GrpcserviceClient) GetWalletStatus(ctx context.Context, in *types.ReqNil, opts ...grpc.CallOption) (*types.WalletStatus, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *types.WalletStatus
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqNil, ...grpc.CallOption) *types.WalletStatus); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.WalletStatus)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqNil, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ImportPrivKey provides a mock function with given fields: ctx, in, opts
func (_m *GrpcserviceClient) ImportPrivKey(ctx context.Context, in *types.ReqWalletImportPrivKey, opts ...grpc.CallOption) (*types.WalletAccount, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *types.WalletAccount
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqWalletImportPrivKey, ...grpc.CallOption) *types.WalletAccount); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.WalletAccount)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqWalletImportPrivKey, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IsNtpClockSync provides a mock function with given fields: ctx, in, opts
func (_m *GrpcserviceClient) IsNtpClockSync(ctx context.Context, in *types.ReqNil, opts ...grpc.CallOption) (*types.Reply, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *types.Reply
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqNil, ...grpc.CallOption) *types.Reply); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Reply)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqNil, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IsSync provides a mock function with given fields: ctx, in, opts
func (_m *GrpcserviceClient) IsSync(ctx context.Context, in *types.ReqNil, opts ...grpc.CallOption) (*types.Reply, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *types.Reply
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqNil, ...grpc.CallOption) *types.Reply); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Reply)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqNil, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Lock provides a mock function with given fields: ctx, in, opts
func (_m *GrpcserviceClient) Lock(ctx context.Context, in *types.ReqNil, opts ...grpc.CallOption) (*types.Reply, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *types.Reply
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqNil, ...grpc.CallOption) *types.Reply); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Reply)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqNil, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MakeTxPrivacy2Privacy provides a mock function with given fields: ctx, in, opts
func (_m *GrpcserviceClient) MakeTxPrivacy2Privacy(ctx context.Context, in *types.ReqPri2Pri, opts ...grpc.CallOption) (*types.Reply, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *types.Reply
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqPri2Pri, ...grpc.CallOption) *types.Reply); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Reply)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqPri2Pri, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MakeTxPrivacy2Public provides a mock function with given fields: ctx, in, opts
func (_m *GrpcserviceClient) MakeTxPrivacy2Public(ctx context.Context, in *types.ReqPri2Pub, opts ...grpc.CallOption) (*types.Reply, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *types.Reply
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqPri2Pub, ...grpc.CallOption) *types.Reply); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Reply)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqPri2Pub, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MakeTxPublic2Privacy provides a mock function with given fields: ctx, in, opts
func (_m *GrpcserviceClient) MakeTxPublic2Privacy(ctx context.Context, in *types.ReqPub2Pri, opts ...grpc.CallOption) (*types.Reply, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *types.Reply
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqPub2Pri, ...grpc.CallOption) *types.Reply); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Reply)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqPub2Pri, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MergeBalance provides a mock function with given fields: ctx, in, opts
func (_m *GrpcserviceClient) MergeBalance(ctx context.Context, in *types.ReqWalletMergeBalance, opts ...grpc.CallOption) (*types.ReplyHashes, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *types.ReplyHashes
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqWalletMergeBalance, ...grpc.CallOption) *types.ReplyHashes); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.ReplyHashes)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqWalletMergeBalance, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NetInfo provides a mock function with given fields: ctx, in, opts
func (_m *GrpcserviceClient) NetInfo(ctx context.Context, in *types.ReqNil, opts ...grpc.CallOption) (*types.NodeNetInfo, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *types.NodeNetInfo
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqNil, ...grpc.CallOption) *types.NodeNetInfo); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.NodeNetInfo)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqNil, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewAccount provides a mock function with given fields: ctx, in, opts
func (_m *GrpcserviceClient) NewAccount(ctx context.Context, in *types.ReqNewAccount, opts ...grpc.CallOption) (*types.WalletAccount, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *types.WalletAccount
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqNewAccount, ...grpc.CallOption) *types.WalletAccount); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.WalletAccount)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqNewAccount, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// QueryChain provides a mock function with given fields: ctx, in, opts
func (_m *GrpcserviceClient) QueryChain(ctx context.Context, in *types.Query, opts ...grpc.CallOption) (*types.Reply, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *types.Reply
	if rf, ok := ret.Get(0).(func(context.Context, *types.Query, ...grpc.CallOption) *types.Reply); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Reply)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.Query, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// QueryTransaction provides a mock function with given fields: ctx, in, opts
func (_m *GrpcserviceClient) QueryTransaction(ctx context.Context, in *types.ReqHash, opts ...grpc.CallOption) (*types.TransactionDetail, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *types.TransactionDetail
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqHash, ...grpc.CallOption) *types.TransactionDetail); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.TransactionDetail)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqHash, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RescanUtxos provides a mock function with given fields: ctx, in, opts
func (_m *GrpcserviceClient) RescanUtxos(ctx context.Context, in *types.ReqRescanUtxos, opts ...grpc.CallOption) (*types.RepRescanUtxos, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *types.RepRescanUtxos
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqRescanUtxos, ...grpc.CallOption) *types.RepRescanUtxos); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.RepRescanUtxos)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqRescanUtxos, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SaveSeed provides a mock function with given fields: ctx, in, opts
func (_m *GrpcserviceClient) SaveSeed(ctx context.Context, in *types.SaveSeedByPw, opts ...grpc.CallOption) (*types.Reply, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *types.Reply
	if rf, ok := ret.Get(0).(func(context.Context, *types.SaveSeedByPw, ...grpc.CallOption) *types.Reply); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Reply)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.SaveSeedByPw, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SendRawTransaction provides a mock function with given fields: ctx, in, opts
func (_m *GrpcserviceClient) SendRawTransaction(ctx context.Context, in *types.SignedTx, opts ...grpc.CallOption) (*types.Reply, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *types.Reply
	if rf, ok := ret.Get(0).(func(context.Context, *types.SignedTx, ...grpc.CallOption) *types.Reply); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Reply)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.SignedTx, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SendToAddress provides a mock function with given fields: ctx, in, opts
func (_m *GrpcserviceClient) SendToAddress(ctx context.Context, in *types.ReqWalletSendToAddress, opts ...grpc.CallOption) (*types.ReplyHash, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *types.ReplyHash
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqWalletSendToAddress, ...grpc.CallOption) *types.ReplyHash); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.ReplyHash)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqWalletSendToAddress, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SendTransaction provides a mock function with given fields: ctx, in, opts
func (_m *GrpcserviceClient) SendTransaction(ctx context.Context, in *types.Transaction, opts ...grpc.CallOption) (*types.Reply, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *types.Reply
	if rf, ok := ret.Get(0).(func(context.Context, *types.Transaction, ...grpc.CallOption) *types.Reply); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Reply)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.Transaction, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SetAutoMining provides a mock function with given fields: ctx, in, opts
func (_m *GrpcserviceClient) SetAutoMining(ctx context.Context, in *types.MinerFlag, opts ...grpc.CallOption) (*types.Reply, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *types.Reply
	if rf, ok := ret.Get(0).(func(context.Context, *types.MinerFlag, ...grpc.CallOption) *types.Reply); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Reply)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.MinerFlag, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SetLabl provides a mock function with given fields: ctx, in, opts
func (_m *GrpcserviceClient) SetLabl(ctx context.Context, in *types.ReqWalletSetLabel, opts ...grpc.CallOption) (*types.WalletAccount, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *types.WalletAccount
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqWalletSetLabel, ...grpc.CallOption) *types.WalletAccount); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.WalletAccount)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqWalletSetLabel, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SetPasswd provides a mock function with given fields: ctx, in, opts
func (_m *GrpcserviceClient) SetPasswd(ctx context.Context, in *types.ReqWalletSetPasswd, opts ...grpc.CallOption) (*types.Reply, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *types.Reply
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqWalletSetPasswd, ...grpc.CallOption) *types.Reply); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Reply)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqWalletSetPasswd, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SetTxFee provides a mock function with given fields: ctx, in, opts
func (_m *GrpcserviceClient) SetTxFee(ctx context.Context, in *types.ReqWalletSetFee, opts ...grpc.CallOption) (*types.Reply, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *types.Reply
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqWalletSetFee, ...grpc.CallOption) *types.Reply); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Reply)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqWalletSetFee, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ShowPrivacyKey provides a mock function with given fields: ctx, in, opts
func (_m *GrpcserviceClient) ShowPrivacyKey(ctx context.Context, in *types.ReqStr, opts ...grpc.CallOption) (*types.ReplyPrivacyPkPair, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *types.ReplyPrivacyPkPair
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqStr, ...grpc.CallOption) *types.ReplyPrivacyPkPair); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.ReplyPrivacyPkPair)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqStr, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SignRawTx provides a mock function with given fields: ctx, in, opts
func (_m *GrpcserviceClient) SignRawTx(ctx context.Context, in *types.ReqSignRawTx, opts ...grpc.CallOption) (*types.ReplySignRawTx, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *types.ReplySignRawTx
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqSignRawTx, ...grpc.CallOption) *types.ReplySignRawTx); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.ReplySignRawTx)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqSignRawTx, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UnLock provides a mock function with given fields: ctx, in, opts
func (_m *GrpcserviceClient) UnLock(ctx context.Context, in *types.WalletUnLock, opts ...grpc.CallOption) (*types.Reply, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *types.Reply
	if rf, ok := ret.Get(0).(func(context.Context, *types.WalletUnLock, ...grpc.CallOption) *types.Reply); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Reply)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.WalletUnLock, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Version provides a mock function with given fields: ctx, in, opts
func (_m *GrpcserviceClient) Version(ctx context.Context, in *types.ReqNil, opts ...grpc.CallOption) (*types.Reply, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *types.Reply
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqNil, ...grpc.CallOption) *types.Reply); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Reply)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqNil, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WalletTransactionList provides a mock function with given fields: ctx, in, opts
func (_m *GrpcserviceClient) WalletTransactionList(ctx context.Context, in *types.ReqWalletTransactionList, opts ...grpc.CallOption) (*types.WalletTxDetails, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *types.WalletTxDetails
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqWalletTransactionList, ...grpc.CallOption) *types.WalletTxDetails); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.WalletTxDetails)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqWalletTransactionList, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}
