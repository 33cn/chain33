// Code generated by mockery v1.0.0. DO NOT EDIT.

package mocks

import context "context"
import grpc "google.golang.org/grpc"
import mock "github.com/stretchr/testify/mock"
import types "github.com/33cn/chain33/types"

// Chain33Client is an autogenerated mock type for the Chain33Client type
type Chain33Client struct {
	mock.Mock
}

// CloseQueue provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) CloseQueue(ctx context.Context, in *types.ReqNil, opts ...grpc.CallOption) (*types.Reply, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *types.Reply
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqNil, ...grpc.CallOption) *types.Reply); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Reply)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqNil, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateNoBalanceTransaction provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) CreateNoBalanceTransaction(ctx context.Context, in *types.NoBalanceTx, opts ...grpc.CallOption) (*types.ReplySignRawTx, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *types.ReplySignRawTx
	if rf, ok := ret.Get(0).(func(context.Context, *types.NoBalanceTx, ...grpc.CallOption) *types.ReplySignRawTx); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.ReplySignRawTx)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.NoBalanceTx, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateNoBalanceTxs provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) CreateNoBalanceTxs(ctx context.Context, in *types.NoBalanceTxs, opts ...grpc.CallOption) (*types.ReplySignRawTx, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *types.ReplySignRawTx
	if rf, ok := ret.Get(0).(func(context.Context, *types.NoBalanceTxs, ...grpc.CallOption) *types.ReplySignRawTx); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.ReplySignRawTx)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.NoBalanceTxs, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateRawTransaction provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) CreateRawTransaction(ctx context.Context, in *types.CreateTx, opts ...grpc.CallOption) (*types.UnsignTx, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *types.UnsignTx
	if rf, ok := ret.Get(0).(func(context.Context, *types.CreateTx, ...grpc.CallOption) *types.UnsignTx); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.UnsignTx)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.CreateTx, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateRawTxGroup provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) CreateRawTxGroup(ctx context.Context, in *types.CreateTransactionGroup, opts ...grpc.CallOption) (*types.UnsignTx, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *types.UnsignTx
	if rf, ok := ret.Get(0).(func(context.Context, *types.CreateTransactionGroup, ...grpc.CallOption) *types.UnsignTx); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.UnsignTx)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.CreateTransactionGroup, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateTransaction provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) CreateTransaction(ctx context.Context, in *types.CreateTxIn, opts ...grpc.CallOption) (*types.UnsignTx, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *types.UnsignTx
	if rf, ok := ret.Get(0).(func(context.Context, *types.CreateTxIn, ...grpc.CallOption) *types.UnsignTx); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.UnsignTx)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.CreateTxIn, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DumpPrivkey provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) DumpPrivkey(ctx context.Context, in *types.ReqString, opts ...grpc.CallOption) (*types.ReplyString, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *types.ReplyString
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqString, ...grpc.CallOption) *types.ReplyString); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.ReplyString)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqString, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ExecWallet provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) ExecWallet(ctx context.Context, in *types.ChainExecutor, opts ...grpc.CallOption) (*types.Reply, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *types.Reply
	if rf, ok := ret.Get(0).(func(context.Context, *types.ChainExecutor, ...grpc.CallOption) *types.Reply); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Reply)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.ChainExecutor, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GenSeed provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) GenSeed(ctx context.Context, in *types.GenSeedLang, opts ...grpc.CallOption) (*types.ReplySeed, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *types.ReplySeed
	if rf, ok := ret.Get(0).(func(context.Context, *types.GenSeedLang, ...grpc.CallOption) *types.ReplySeed); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.ReplySeed)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.GenSeedLang, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAccounts provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) GetAccounts(ctx context.Context, in *types.ReqNil, opts ...grpc.CallOption) (*types.WalletAccounts, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *types.WalletAccounts
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqNil, ...grpc.CallOption) *types.WalletAccounts); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.WalletAccounts)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqNil, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAddrOverview provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) GetAddrOverview(ctx context.Context, in *types.ReqAddr, opts ...grpc.CallOption) (*types.AddrOverview, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *types.AddrOverview
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqAddr, ...grpc.CallOption) *types.AddrOverview); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.AddrOverview)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqAddr, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAllExecBalance provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) GetAllExecBalance(ctx context.Context, in *types.ReqAllExecBalance, opts ...grpc.CallOption) (*types.AllExecBalance, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *types.AllExecBalance
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqAllExecBalance, ...grpc.CallOption) *types.AllExecBalance); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.AllExecBalance)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqAllExecBalance, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBalance provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) GetBalance(ctx context.Context, in *types.ReqBalance, opts ...grpc.CallOption) (*types.Accounts, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *types.Accounts
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqBalance, ...grpc.CallOption) *types.Accounts); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Accounts)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqBalance, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBlockByHashes provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) GetBlockByHashes(ctx context.Context, in *types.ReqHashes, opts ...grpc.CallOption) (*types.BlockDetails, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *types.BlockDetails
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqHashes, ...grpc.CallOption) *types.BlockDetails); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.BlockDetails)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqHashes, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBlockBySeq provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) GetBlockBySeq(ctx context.Context, in *types.Int64, opts ...grpc.CallOption) (*types.BlockSeq, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *types.BlockSeq
	if rf, ok := ret.Get(0).(func(context.Context, *types.Int64, ...grpc.CallOption) *types.BlockSeq); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.BlockSeq)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.Int64, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBlockHash provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) GetBlockHash(ctx context.Context, in *types.ReqInt, opts ...grpc.CallOption) (*types.ReplyHash, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *types.ReplyHash
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqInt, ...grpc.CallOption) *types.ReplyHash); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.ReplyHash)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqInt, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBlockOverview provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) GetBlockOverview(ctx context.Context, in *types.ReqHash, opts ...grpc.CallOption) (*types.BlockOverview, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *types.BlockOverview
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqHash, ...grpc.CallOption) *types.BlockOverview); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.BlockOverview)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqHash, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBlocks provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) GetBlocks(ctx context.Context, in *types.ReqBlocks, opts ...grpc.CallOption) (*types.Reply, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *types.Reply
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqBlocks, ...grpc.CallOption) *types.Reply); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Reply)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqBlocks, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetFatalFailure provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) GetFatalFailure(ctx context.Context, in *types.ReqNil, opts ...grpc.CallOption) (*types.Int32, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *types.Int32
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqNil, ...grpc.CallOption) *types.Int32); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Int32)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqNil, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetFork provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) GetFork(ctx context.Context, in *types.ReqKey, opts ...grpc.CallOption) (*types.Int64, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *types.Int64
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqKey, ...grpc.CallOption) *types.Int64); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Int64)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqKey, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetHexTxByHash provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) GetHexTxByHash(ctx context.Context, in *types.ReqHash, opts ...grpc.CallOption) (*types.HexTx, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *types.HexTx
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqHash, ...grpc.CallOption) *types.HexTx); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.HexTx)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqHash, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetLastBlockSequence provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) GetLastBlockSequence(ctx context.Context, in *types.ReqNil, opts ...grpc.CallOption) (*types.Int64, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *types.Int64
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqNil, ...grpc.CallOption) *types.Int64); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Int64)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqNil, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetLastHeader provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) GetLastHeader(ctx context.Context, in *types.ReqNil, opts ...grpc.CallOption) (*types.Header, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *types.Header
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqNil, ...grpc.CallOption) *types.Header); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Header)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqNil, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetLastMemPool provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) GetLastMemPool(ctx context.Context, in *types.ReqNil, opts ...grpc.CallOption) (*types.ReplyTxList, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *types.ReplyTxList
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqNil, ...grpc.CallOption) *types.ReplyTxList); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.ReplyTxList)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqNil, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetMemPool provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) GetMemPool(ctx context.Context, in *types.ReqGetMempool, opts ...grpc.CallOption) (*types.ReplyTxList, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *types.ReplyTxList
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqGetMempool, ...grpc.CallOption) *types.ReplyTxList); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.ReplyTxList)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqGetMempool, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetParaTxByTitle provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) GetParaTxByTitle(ctx context.Context, in *types.ReqParaTxByTitle, opts ...grpc.CallOption) (*types.ParaTxDetails, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *types.ParaTxDetails
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqParaTxByTitle, ...grpc.CallOption) *types.ParaTxDetails); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.ParaTxDetails)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqParaTxByTitle, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetPeerInfo provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) GetPeerInfo(ctx context.Context, in *types.ReqNil, opts ...grpc.CallOption) (*types.PeerList, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *types.PeerList
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqNil, ...grpc.CallOption) *types.PeerList); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.PeerList)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqNil, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetProperFee provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) GetProperFee(ctx context.Context, in *types.ReqProperFee, opts ...grpc.CallOption) (*types.ReplyProperFee, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *types.ReplyProperFee
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqProperFee, ...grpc.CallOption) *types.ReplyProperFee); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.ReplyProperFee)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqProperFee, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetSeed provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) GetSeed(ctx context.Context, in *types.GetSeedByPw, opts ...grpc.CallOption) (*types.ReplySeed, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *types.ReplySeed
	if rf, ok := ret.Get(0).(func(context.Context, *types.GetSeedByPw, ...grpc.CallOption) *types.ReplySeed); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.ReplySeed)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.GetSeedByPw, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetSequenceByHash provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) GetSequenceByHash(ctx context.Context, in *types.ReqHash, opts ...grpc.CallOption) (*types.Int64, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *types.Int64
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqHash, ...grpc.CallOption) *types.Int64); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Int64)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqHash, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTransactionByAddr provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) GetTransactionByAddr(ctx context.Context, in *types.ReqAddr, opts ...grpc.CallOption) (*types.ReplyTxInfos, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *types.ReplyTxInfos
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqAddr, ...grpc.CallOption) *types.ReplyTxInfos); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.ReplyTxInfos)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqAddr, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTransactionByHashes provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) GetTransactionByHashes(ctx context.Context, in *types.ReqHashes, opts ...grpc.CallOption) (*types.TransactionDetails, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *types.TransactionDetails
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqHashes, ...grpc.CallOption) *types.TransactionDetails); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.TransactionDetails)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqHashes, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetWalletStatus provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) GetWalletStatus(ctx context.Context, in *types.ReqNil, opts ...grpc.CallOption) (*types.WalletStatus, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *types.WalletStatus
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqNil, ...grpc.CallOption) *types.WalletStatus); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.WalletStatus)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqNil, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ImportPrivkey provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) ImportPrivkey(ctx context.Context, in *types.ReqWalletImportPrivkey, opts ...grpc.CallOption) (*types.WalletAccount, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *types.WalletAccount
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqWalletImportPrivkey, ...grpc.CallOption) *types.WalletAccount); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.WalletAccount)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqWalletImportPrivkey, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IsNtpClockSync provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) IsNtpClockSync(ctx context.Context, in *types.ReqNil, opts ...grpc.CallOption) (*types.Reply, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *types.Reply
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqNil, ...grpc.CallOption) *types.Reply); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Reply)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqNil, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IsSync provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) IsSync(ctx context.Context, in *types.ReqNil, opts ...grpc.CallOption) (*types.Reply, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *types.Reply
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqNil, ...grpc.CallOption) *types.Reply); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Reply)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqNil, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Lock provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) Lock(ctx context.Context, in *types.ReqNil, opts ...grpc.CallOption) (*types.Reply, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *types.Reply
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqNil, ...grpc.CallOption) *types.Reply); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Reply)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqNil, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MergeBalance provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) MergeBalance(ctx context.Context, in *types.ReqWalletMergeBalance, opts ...grpc.CallOption) (*types.ReplyHashes, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *types.ReplyHashes
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqWalletMergeBalance, ...grpc.CallOption) *types.ReplyHashes); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.ReplyHashes)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqWalletMergeBalance, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NetInfo provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) NetInfo(ctx context.Context, in *types.ReqNil, opts ...grpc.CallOption) (*types.NodeNetInfo, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *types.NodeNetInfo
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqNil, ...grpc.CallOption) *types.NodeNetInfo); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.NodeNetInfo)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqNil, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewAccount provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) NewAccount(ctx context.Context, in *types.ReqNewAccount, opts ...grpc.CallOption) (*types.WalletAccount, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *types.WalletAccount
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqNewAccount, ...grpc.CallOption) *types.WalletAccount); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.WalletAccount)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqNewAccount, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// QueryChain provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) QueryChain(ctx context.Context, in *types.ChainExecutor, opts ...grpc.CallOption) (*types.Reply, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *types.Reply
	if rf, ok := ret.Get(0).(func(context.Context, *types.ChainExecutor, ...grpc.CallOption) *types.Reply); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Reply)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.ChainExecutor, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// QueryConsensus provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) QueryConsensus(ctx context.Context, in *types.ChainExecutor, opts ...grpc.CallOption) (*types.Reply, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *types.Reply
	if rf, ok := ret.Get(0).(func(context.Context, *types.ChainExecutor, ...grpc.CallOption) *types.Reply); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Reply)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.ChainExecutor, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// QueryRandNum provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) QueryRandNum(ctx context.Context, in *types.ReqRandHash, opts ...grpc.CallOption) (*types.ReplyHash, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *types.ReplyHash
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqRandHash, ...grpc.CallOption) *types.ReplyHash); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.ReplyHash)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqRandHash, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// QueryTransaction provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) QueryTransaction(ctx context.Context, in *types.ReqHash, opts ...grpc.CallOption) (*types.TransactionDetail, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *types.TransactionDetail
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqHash, ...grpc.CallOption) *types.TransactionDetail); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.TransactionDetail)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqHash, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SaveSeed provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) SaveSeed(ctx context.Context, in *types.SaveSeedByPw, opts ...grpc.CallOption) (*types.Reply, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *types.Reply
	if rf, ok := ret.Get(0).(func(context.Context, *types.SaveSeedByPw, ...grpc.CallOption) *types.Reply); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Reply)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.SaveSeedByPw, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SendToAddress provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) SendToAddress(ctx context.Context, in *types.ReqWalletSendToAddress, opts ...grpc.CallOption) (*types.ReplyHash, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *types.ReplyHash
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqWalletSendToAddress, ...grpc.CallOption) *types.ReplyHash); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.ReplyHash)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqWalletSendToAddress, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SendTransaction provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) SendTransaction(ctx context.Context, in *types.Transaction, opts ...grpc.CallOption) (*types.Reply, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *types.Reply
	if rf, ok := ret.Get(0).(func(context.Context, *types.Transaction, ...grpc.CallOption) *types.Reply); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Reply)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.Transaction, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SetLabl provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) SetLabl(ctx context.Context, in *types.ReqWalletSetLabel, opts ...grpc.CallOption) (*types.WalletAccount, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *types.WalletAccount
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqWalletSetLabel, ...grpc.CallOption) *types.WalletAccount); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.WalletAccount)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqWalletSetLabel, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SetPasswd provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) SetPasswd(ctx context.Context, in *types.ReqWalletSetPasswd, opts ...grpc.CallOption) (*types.Reply, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *types.Reply
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqWalletSetPasswd, ...grpc.CallOption) *types.Reply); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Reply)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqWalletSetPasswd, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SetTxFee provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) SetTxFee(ctx context.Context, in *types.ReqWalletSetFee, opts ...grpc.CallOption) (*types.Reply, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *types.Reply
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqWalletSetFee, ...grpc.CallOption) *types.Reply); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Reply)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqWalletSetFee, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SignRawTx provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) SignRawTx(ctx context.Context, in *types.ReqSignRawTx, opts ...grpc.CallOption) (*types.ReplySignRawTx, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *types.ReplySignRawTx
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqSignRawTx, ...grpc.CallOption) *types.ReplySignRawTx); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.ReplySignRawTx)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqSignRawTx, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UnLock provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) UnLock(ctx context.Context, in *types.WalletUnLock, opts ...grpc.CallOption) (*types.Reply, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *types.Reply
	if rf, ok := ret.Get(0).(func(context.Context, *types.WalletUnLock, ...grpc.CallOption) *types.Reply); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Reply)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.WalletUnLock, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Version provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) Version(ctx context.Context, in *types.ReqNil, opts ...grpc.CallOption) (*types.VersionInfo, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *types.VersionInfo
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqNil, ...grpc.CallOption) *types.VersionInfo); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.VersionInfo)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqNil, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WalletTransactionList provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) WalletTransactionList(ctx context.Context, in *types.ReqWalletTransactionList, opts ...grpc.CallOption) (*types.WalletTxDetails, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *types.WalletTxDetails
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqWalletTransactionList, ...grpc.CallOption) *types.WalletTxDetails); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.WalletTxDetails)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqWalletTransactionList, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}
