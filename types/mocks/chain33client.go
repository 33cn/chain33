// Code generated by mockery v2.38.0. DO NOT EDIT.

package mocks

import (
	context "context"

	grpc "google.golang.org/grpc"

	mock "github.com/stretchr/testify/mock"

	types "github.com/33cn/chain33/types"
)

// Chain33Client is an autogenerated mock type for the Chain33Client type
type Chain33Client struct {
	mock.Mock
}

// AddPushSubscribe provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) AddPushSubscribe(ctx context.Context, in *types.PushSubscribeReq, opts ...grpc.CallOption) (*types.ReplySubscribePush, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddPushSubscribe")
	}

	var r0 *types.ReplySubscribePush
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.PushSubscribeReq, ...grpc.CallOption) (*types.ReplySubscribePush, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.PushSubscribeReq, ...grpc.CallOption) *types.ReplySubscribePush); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.ReplySubscribePush)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.PushSubscribeReq, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CloseQueue provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) CloseQueue(ctx context.Context, in *types.ReqNil, opts ...grpc.CallOption) (*types.Reply, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CloseQueue")
	}

	var r0 *types.Reply
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqNil, ...grpc.CallOption) (*types.Reply, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqNil, ...grpc.CallOption) *types.Reply); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Reply)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqNil, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ConvertExectoAddr provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) ConvertExectoAddr(ctx context.Context, in *types.ReqString, opts ...grpc.CallOption) (*types.ReplyString, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ConvertExectoAddr")
	}

	var r0 *types.ReplyString
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqString, ...grpc.CallOption) (*types.ReplyString, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqString, ...grpc.CallOption) *types.ReplyString); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.ReplyString)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqString, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateNoBalanceTransaction provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) CreateNoBalanceTransaction(ctx context.Context, in *types.NoBalanceTx, opts ...grpc.CallOption) (*types.ReplySignRawTx, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateNoBalanceTransaction")
	}

	var r0 *types.ReplySignRawTx
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.NoBalanceTx, ...grpc.CallOption) (*types.ReplySignRawTx, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.NoBalanceTx, ...grpc.CallOption) *types.ReplySignRawTx); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.ReplySignRawTx)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.NoBalanceTx, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateNoBalanceTxs provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) CreateNoBalanceTxs(ctx context.Context, in *types.NoBalanceTxs, opts ...grpc.CallOption) (*types.ReplySignRawTx, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateNoBalanceTxs")
	}

	var r0 *types.ReplySignRawTx
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.NoBalanceTxs, ...grpc.CallOption) (*types.ReplySignRawTx, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.NoBalanceTxs, ...grpc.CallOption) *types.ReplySignRawTx); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.ReplySignRawTx)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.NoBalanceTxs, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateRawTransaction provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) CreateRawTransaction(ctx context.Context, in *types.CreateTx, opts ...grpc.CallOption) (*types.UnsignTx, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateRawTransaction")
	}

	var r0 *types.UnsignTx
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.CreateTx, ...grpc.CallOption) (*types.UnsignTx, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.CreateTx, ...grpc.CallOption) *types.UnsignTx); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.UnsignTx)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.CreateTx, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateRawTxGroup provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) CreateRawTxGroup(ctx context.Context, in *types.CreateTransactionGroup, opts ...grpc.CallOption) (*types.UnsignTx, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateRawTxGroup")
	}

	var r0 *types.UnsignTx
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.CreateTransactionGroup, ...grpc.CallOption) (*types.UnsignTx, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.CreateTransactionGroup, ...grpc.CallOption) *types.UnsignTx); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.UnsignTx)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.CreateTransactionGroup, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateTransaction provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) CreateTransaction(ctx context.Context, in *types.CreateTxIn, opts ...grpc.CallOption) (*types.UnsignTx, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateTransaction")
	}

	var r0 *types.UnsignTx
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.CreateTxIn, ...grpc.CallOption) (*types.UnsignTx, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.CreateTxIn, ...grpc.CallOption) *types.UnsignTx); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.UnsignTx)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.CreateTxIn, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DumpPrivkey provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) DumpPrivkey(ctx context.Context, in *types.ReqString, opts ...grpc.CallOption) (*types.ReplyString, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DumpPrivkey")
	}

	var r0 *types.ReplyString
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqString, ...grpc.CallOption) (*types.ReplyString, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqString, ...grpc.CallOption) *types.ReplyString); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.ReplyString)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqString, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DumpPrivkeysFile provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) DumpPrivkeysFile(ctx context.Context, in *types.ReqPrivkeysFile, opts ...grpc.CallOption) (*types.Reply, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DumpPrivkeysFile")
	}

	var r0 *types.Reply
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqPrivkeysFile, ...grpc.CallOption) (*types.Reply, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqPrivkeysFile, ...grpc.CallOption) *types.Reply); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Reply)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqPrivkeysFile, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ExecWallet provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) ExecWallet(ctx context.Context, in *types.ChainExecutor, opts ...grpc.CallOption) (*types.Reply, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ExecWallet")
	}

	var r0 *types.Reply
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.ChainExecutor, ...grpc.CallOption) (*types.Reply, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.ChainExecutor, ...grpc.CallOption) *types.Reply); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Reply)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.ChainExecutor, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GenSeed provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) GenSeed(ctx context.Context, in *types.GenSeedLang, opts ...grpc.CallOption) (*types.ReplySeed, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GenSeed")
	}

	var r0 *types.ReplySeed
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.GenSeedLang, ...grpc.CallOption) (*types.ReplySeed, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.GenSeedLang, ...grpc.CallOption) *types.ReplySeed); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.ReplySeed)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.GenSeedLang, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAccount provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) GetAccount(ctx context.Context, in *types.ReqGetAccount, opts ...grpc.CallOption) (*types.WalletAccount, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetAccount")
	}

	var r0 *types.WalletAccount
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqGetAccount, ...grpc.CallOption) (*types.WalletAccount, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqGetAccount, ...grpc.CallOption) *types.WalletAccount); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.WalletAccount)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqGetAccount, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAccounts provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) GetAccounts(ctx context.Context, in *types.ReqNil, opts ...grpc.CallOption) (*types.WalletAccounts, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetAccounts")
	}

	var r0 *types.WalletAccounts
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqNil, ...grpc.CallOption) (*types.WalletAccounts, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqNil, ...grpc.CallOption) *types.WalletAccounts); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.WalletAccounts)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqNil, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAddrOverview provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) GetAddrOverview(ctx context.Context, in *types.ReqAddr, opts ...grpc.CallOption) (*types.AddrOverview, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetAddrOverview")
	}

	var r0 *types.AddrOverview
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqAddr, ...grpc.CallOption) (*types.AddrOverview, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqAddr, ...grpc.CallOption) *types.AddrOverview); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.AddrOverview)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqAddr, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAddressDrivers provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) GetAddressDrivers(ctx context.Context, in *types.ReqNil, opts ...grpc.CallOption) (*types.AddressDrivers, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetAddressDrivers")
	}

	var r0 *types.AddressDrivers
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqNil, ...grpc.CallOption) (*types.AddressDrivers, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqNil, ...grpc.CallOption) *types.AddressDrivers); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.AddressDrivers)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqNil, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAllExecBalance provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) GetAllExecBalance(ctx context.Context, in *types.ReqAllExecBalance, opts ...grpc.CallOption) (*types.AllExecBalance, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetAllExecBalance")
	}

	var r0 *types.AllExecBalance
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqAllExecBalance, ...grpc.CallOption) (*types.AllExecBalance, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqAllExecBalance, ...grpc.CallOption) *types.AllExecBalance); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.AllExecBalance)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqAllExecBalance, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBalance provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) GetBalance(ctx context.Context, in *types.ReqBalance, opts ...grpc.CallOption) (*types.Accounts, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetBalance")
	}

	var r0 *types.Accounts
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqBalance, ...grpc.CallOption) (*types.Accounts, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqBalance, ...grpc.CallOption) *types.Accounts); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Accounts)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqBalance, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBlockByHashes provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) GetBlockByHashes(ctx context.Context, in *types.ReqHashes, opts ...grpc.CallOption) (*types.BlockDetails, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetBlockByHashes")
	}

	var r0 *types.BlockDetails
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqHashes, ...grpc.CallOption) (*types.BlockDetails, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqHashes, ...grpc.CallOption) *types.BlockDetails); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.BlockDetails)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqHashes, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBlockBySeq provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) GetBlockBySeq(ctx context.Context, in *types.Int64, opts ...grpc.CallOption) (*types.BlockSeq, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetBlockBySeq")
	}

	var r0 *types.BlockSeq
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.Int64, ...grpc.CallOption) (*types.BlockSeq, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.Int64, ...grpc.CallOption) *types.BlockSeq); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.BlockSeq)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.Int64, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBlockHash provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) GetBlockHash(ctx context.Context, in *types.ReqInt, opts ...grpc.CallOption) (*types.ReplyHash, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetBlockHash")
	}

	var r0 *types.ReplyHash
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqInt, ...grpc.CallOption) (*types.ReplyHash, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqInt, ...grpc.CallOption) *types.ReplyHash); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.ReplyHash)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqInt, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBlockOverview provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) GetBlockOverview(ctx context.Context, in *types.ReqHash, opts ...grpc.CallOption) (*types.BlockOverview, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetBlockOverview")
	}

	var r0 *types.BlockOverview
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqHash, ...grpc.CallOption) (*types.BlockOverview, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqHash, ...grpc.CallOption) *types.BlockOverview); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.BlockOverview)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqHash, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBlockSequences provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) GetBlockSequences(ctx context.Context, in *types.ReqBlocks, opts ...grpc.CallOption) (*types.BlockSequences, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetBlockSequences")
	}

	var r0 *types.BlockSequences
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqBlocks, ...grpc.CallOption) (*types.BlockSequences, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqBlocks, ...grpc.CallOption) *types.BlockSequences); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.BlockSequences)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqBlocks, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBlocks provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) GetBlocks(ctx context.Context, in *types.ReqBlocks, opts ...grpc.CallOption) (*types.Reply, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetBlocks")
	}

	var r0 *types.Reply
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqBlocks, ...grpc.CallOption) (*types.Reply, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqBlocks, ...grpc.CallOption) *types.Reply); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Reply)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqBlocks, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetChainConfig provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) GetChainConfig(ctx context.Context, in *types.ReqNil, opts ...grpc.CallOption) (*types.ChainConfigInfo, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetChainConfig")
	}

	var r0 *types.ChainConfigInfo
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqNil, ...grpc.CallOption) (*types.ChainConfigInfo, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqNil, ...grpc.CallOption) *types.ChainConfigInfo); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.ChainConfigInfo)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqNil, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetCoinSymbol provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) GetCoinSymbol(ctx context.Context, in *types.ReqNil, opts ...grpc.CallOption) (*types.ReplyString, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetCoinSymbol")
	}

	var r0 *types.ReplyString
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqNil, ...grpc.CallOption) (*types.ReplyString, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqNil, ...grpc.CallOption) *types.ReplyString); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.ReplyString)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqNil, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetCryptoList provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) GetCryptoList(ctx context.Context, in *types.ReqNil, opts ...grpc.CallOption) (*types.CryptoList, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetCryptoList")
	}

	var r0 *types.CryptoList
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqNil, ...grpc.CallOption) (*types.CryptoList, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqNil, ...grpc.CallOption) *types.CryptoList); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.CryptoList)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqNil, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetFatalFailure provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) GetFatalFailure(ctx context.Context, in *types.ReqNil, opts ...grpc.CallOption) (*types.Int32, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetFatalFailure")
	}

	var r0 *types.Int32
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqNil, ...grpc.CallOption) (*types.Int32, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqNil, ...grpc.CallOption) *types.Int32); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Int32)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqNil, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetFinalizedBlock provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) GetFinalizedBlock(ctx context.Context, in *types.ReqNil, opts ...grpc.CallOption) (*types.SnowChoice, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetFinalizedBlock")
	}

	var r0 *types.SnowChoice
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqNil, ...grpc.CallOption) (*types.SnowChoice, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqNil, ...grpc.CallOption) *types.SnowChoice); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.SnowChoice)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqNil, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetFork provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) GetFork(ctx context.Context, in *types.ReqKey, opts ...grpc.CallOption) (*types.Int64, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetFork")
	}

	var r0 *types.Int64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqKey, ...grpc.CallOption) (*types.Int64, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqKey, ...grpc.CallOption) *types.Int64); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Int64)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqKey, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetHeaders provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) GetHeaders(ctx context.Context, in *types.ReqBlocks, opts ...grpc.CallOption) (*types.Headers, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetHeaders")
	}

	var r0 *types.Headers
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqBlocks, ...grpc.CallOption) (*types.Headers, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqBlocks, ...grpc.CallOption) *types.Headers); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Headers)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqBlocks, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetHexTxByHash provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) GetHexTxByHash(ctx context.Context, in *types.ReqHash, opts ...grpc.CallOption) (*types.HexTx, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetHexTxByHash")
	}

	var r0 *types.HexTx
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqHash, ...grpc.CallOption) (*types.HexTx, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqHash, ...grpc.CallOption) *types.HexTx); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.HexTx)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqHash, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetLastBlockSequence provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) GetLastBlockSequence(ctx context.Context, in *types.ReqNil, opts ...grpc.CallOption) (*types.Int64, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetLastBlockSequence")
	}

	var r0 *types.Int64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqNil, ...grpc.CallOption) (*types.Int64, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqNil, ...grpc.CallOption) *types.Int64); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Int64)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqNil, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetLastHeader provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) GetLastHeader(ctx context.Context, in *types.ReqNil, opts ...grpc.CallOption) (*types.Header, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetLastHeader")
	}

	var r0 *types.Header
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqNil, ...grpc.CallOption) (*types.Header, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqNil, ...grpc.CallOption) *types.Header); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Header)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqNil, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetLastMemPool provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) GetLastMemPool(ctx context.Context, in *types.ReqNil, opts ...grpc.CallOption) (*types.ReplyTxList, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetLastMemPool")
	}

	var r0 *types.ReplyTxList
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqNil, ...grpc.CallOption) (*types.ReplyTxList, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqNil, ...grpc.CallOption) *types.ReplyTxList); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.ReplyTxList)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqNil, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetMemPool provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) GetMemPool(ctx context.Context, in *types.ReqGetMempool, opts ...grpc.CallOption) (*types.ReplyTxList, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetMemPool")
	}

	var r0 *types.ReplyTxList
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqGetMempool, ...grpc.CallOption) (*types.ReplyTxList, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqGetMempool, ...grpc.CallOption) *types.ReplyTxList); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.ReplyTxList)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqGetMempool, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetParaTxByHeight provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) GetParaTxByHeight(ctx context.Context, in *types.ReqParaTxByHeight, opts ...grpc.CallOption) (*types.ParaTxDetails, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetParaTxByHeight")
	}

	var r0 *types.ParaTxDetails
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqParaTxByHeight, ...grpc.CallOption) (*types.ParaTxDetails, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqParaTxByHeight, ...grpc.CallOption) *types.ParaTxDetails); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.ParaTxDetails)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqParaTxByHeight, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetParaTxByTitle provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) GetParaTxByTitle(ctx context.Context, in *types.ReqParaTxByTitle, opts ...grpc.CallOption) (*types.ParaTxDetails, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetParaTxByTitle")
	}

	var r0 *types.ParaTxDetails
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqParaTxByTitle, ...grpc.CallOption) (*types.ParaTxDetails, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqParaTxByTitle, ...grpc.CallOption) *types.ParaTxDetails); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.ParaTxDetails)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqParaTxByTitle, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetPeerInfo provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) GetPeerInfo(ctx context.Context, in *types.P2PGetPeerReq, opts ...grpc.CallOption) (*types.PeerList, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetPeerInfo")
	}

	var r0 *types.PeerList
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.P2PGetPeerReq, ...grpc.CallOption) (*types.PeerList, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.P2PGetPeerReq, ...grpc.CallOption) *types.PeerList); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.PeerList)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.P2PGetPeerReq, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetProperFee provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) GetProperFee(ctx context.Context, in *types.ReqProperFee, opts ...grpc.CallOption) (*types.ReplyProperFee, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetProperFee")
	}

	var r0 *types.ReplyProperFee
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqProperFee, ...grpc.CallOption) (*types.ReplyProperFee, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqProperFee, ...grpc.CallOption) *types.ReplyProperFee); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.ReplyProperFee)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqProperFee, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetPushSeqLastNum provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) GetPushSeqLastNum(ctx context.Context, in *types.ReqString, opts ...grpc.CallOption) (*types.Int64, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetPushSeqLastNum")
	}

	var r0 *types.Int64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqString, ...grpc.CallOption) (*types.Int64, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqString, ...grpc.CallOption) *types.Int64); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Int64)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqString, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetSeed provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) GetSeed(ctx context.Context, in *types.GetSeedByPw, opts ...grpc.CallOption) (*types.ReplySeed, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetSeed")
	}

	var r0 *types.ReplySeed
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.GetSeedByPw, ...grpc.CallOption) (*types.ReplySeed, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.GetSeedByPw, ...grpc.CallOption) *types.ReplySeed); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.ReplySeed)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.GetSeedByPw, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetSequenceByHash provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) GetSequenceByHash(ctx context.Context, in *types.ReqHash, opts ...grpc.CallOption) (*types.Int64, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetSequenceByHash")
	}

	var r0 *types.Int64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqHash, ...grpc.CallOption) (*types.Int64, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqHash, ...grpc.CallOption) *types.Int64); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Int64)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqHash, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetServerTime provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) GetServerTime(ctx context.Context, in *types.ReqNil, opts ...grpc.CallOption) (*types.ServerTime, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetServerTime")
	}

	var r0 *types.ServerTime
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqNil, ...grpc.CallOption) (*types.ServerTime, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqNil, ...grpc.CallOption) *types.ServerTime); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.ServerTime)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqNil, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTransactionByAddr provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) GetTransactionByAddr(ctx context.Context, in *types.ReqAddr, opts ...grpc.CallOption) (*types.ReplyTxInfos, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetTransactionByAddr")
	}

	var r0 *types.ReplyTxInfos
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqAddr, ...grpc.CallOption) (*types.ReplyTxInfos, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqAddr, ...grpc.CallOption) *types.ReplyTxInfos); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.ReplyTxInfos)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqAddr, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTransactionByHashes provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) GetTransactionByHashes(ctx context.Context, in *types.ReqHashes, opts ...grpc.CallOption) (*types.TransactionDetails, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetTransactionByHashes")
	}

	var r0 *types.TransactionDetails
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqHashes, ...grpc.CallOption) (*types.TransactionDetails, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqHashes, ...grpc.CallOption) *types.TransactionDetails); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.TransactionDetails)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqHashes, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetWalletRecoverAddress provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) GetWalletRecoverAddress(ctx context.Context, in *types.ReqGetWalletRecoverAddr, opts ...grpc.CallOption) (*types.ReplyString, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetWalletRecoverAddress")
	}

	var r0 *types.ReplyString
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqGetWalletRecoverAddr, ...grpc.CallOption) (*types.ReplyString, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqGetWalletRecoverAddr, ...grpc.CallOption) *types.ReplyString); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.ReplyString)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqGetWalletRecoverAddr, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetWalletStatus provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) GetWalletStatus(ctx context.Context, in *types.ReqNil, opts ...grpc.CallOption) (*types.WalletStatus, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetWalletStatus")
	}

	var r0 *types.WalletStatus
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqNil, ...grpc.CallOption) (*types.WalletStatus, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqNil, ...grpc.CallOption) *types.WalletStatus); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.WalletStatus)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqNil, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ImportPrivkey provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) ImportPrivkey(ctx context.Context, in *types.ReqWalletImportPrivkey, opts ...grpc.CallOption) (*types.WalletAccount, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ImportPrivkey")
	}

	var r0 *types.WalletAccount
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqWalletImportPrivkey, ...grpc.CallOption) (*types.WalletAccount, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqWalletImportPrivkey, ...grpc.CallOption) *types.WalletAccount); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.WalletAccount)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqWalletImportPrivkey, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ImportPrivkeysFile provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) ImportPrivkeysFile(ctx context.Context, in *types.ReqPrivkeysFile, opts ...grpc.CallOption) (*types.Reply, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ImportPrivkeysFile")
	}

	var r0 *types.Reply
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqPrivkeysFile, ...grpc.CallOption) (*types.Reply, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqPrivkeysFile, ...grpc.CallOption) *types.Reply); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Reply)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqPrivkeysFile, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IsNtpClockSync provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) IsNtpClockSync(ctx context.Context, in *types.ReqNil, opts ...grpc.CallOption) (*types.Reply, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for IsNtpClockSync")
	}

	var r0 *types.Reply
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqNil, ...grpc.CallOption) (*types.Reply, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqNil, ...grpc.CallOption) *types.Reply); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Reply)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqNil, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IsSync provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) IsSync(ctx context.Context, in *types.ReqNil, opts ...grpc.CallOption) (*types.Reply, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for IsSync")
	}

	var r0 *types.Reply
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqNil, ...grpc.CallOption) (*types.Reply, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqNil, ...grpc.CallOption) *types.Reply); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Reply)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqNil, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListPushes provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) ListPushes(ctx context.Context, in *types.ReqNil, opts ...grpc.CallOption) (*types.PushSubscribes, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListPushes")
	}

	var r0 *types.PushSubscribes
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqNil, ...grpc.CallOption) (*types.PushSubscribes, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqNil, ...grpc.CallOption) *types.PushSubscribes); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.PushSubscribes)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqNil, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LoadParaTxByTitle provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) LoadParaTxByTitle(ctx context.Context, in *types.ReqHeightByTitle, opts ...grpc.CallOption) (*types.ReplyHeightByTitle, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for LoadParaTxByTitle")
	}

	var r0 *types.ReplyHeightByTitle
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqHeightByTitle, ...grpc.CallOption) (*types.ReplyHeightByTitle, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqHeightByTitle, ...grpc.CallOption) *types.ReplyHeightByTitle); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.ReplyHeightByTitle)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqHeightByTitle, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Lock provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) Lock(ctx context.Context, in *types.ReqNil, opts ...grpc.CallOption) (*types.Reply, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Lock")
	}

	var r0 *types.Reply
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqNil, ...grpc.CallOption) (*types.Reply, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqNil, ...grpc.CallOption) *types.Reply); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Reply)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqNil, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MergeBalance provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) MergeBalance(ctx context.Context, in *types.ReqWalletMergeBalance, opts ...grpc.CallOption) (*types.ReplyHashes, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for MergeBalance")
	}

	var r0 *types.ReplyHashes
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqWalletMergeBalance, ...grpc.CallOption) (*types.ReplyHashes, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqWalletMergeBalance, ...grpc.CallOption) *types.ReplyHashes); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.ReplyHashes)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqWalletMergeBalance, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NetInfo provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) NetInfo(ctx context.Context, in *types.P2PGetNetInfoReq, opts ...grpc.CallOption) (*types.NodeNetInfo, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for NetInfo")
	}

	var r0 *types.NodeNetInfo
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.P2PGetNetInfoReq, ...grpc.CallOption) (*types.NodeNetInfo, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.P2PGetNetInfoReq, ...grpc.CallOption) *types.NodeNetInfo); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.NodeNetInfo)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.P2PGetNetInfoReq, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewAccount provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) NewAccount(ctx context.Context, in *types.ReqNewAccount, opts ...grpc.CallOption) (*types.WalletAccount, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for NewAccount")
	}

	var r0 *types.WalletAccount
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqNewAccount, ...grpc.CallOption) (*types.WalletAccount, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqNewAccount, ...grpc.CallOption) *types.WalletAccount); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.WalletAccount)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqNewAccount, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// QueryChain provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) QueryChain(ctx context.Context, in *types.ChainExecutor, opts ...grpc.CallOption) (*types.Reply, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for QueryChain")
	}

	var r0 *types.Reply
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.ChainExecutor, ...grpc.CallOption) (*types.Reply, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.ChainExecutor, ...grpc.CallOption) *types.Reply); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Reply)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.ChainExecutor, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// QueryConsensus provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) QueryConsensus(ctx context.Context, in *types.ChainExecutor, opts ...grpc.CallOption) (*types.Reply, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for QueryConsensus")
	}

	var r0 *types.Reply
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.ChainExecutor, ...grpc.CallOption) (*types.Reply, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.ChainExecutor, ...grpc.CallOption) *types.Reply); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Reply)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.ChainExecutor, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// QueryRandNum provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) QueryRandNum(ctx context.Context, in *types.ReqRandHash, opts ...grpc.CallOption) (*types.ReplyHash, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for QueryRandNum")
	}

	var r0 *types.ReplyHash
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqRandHash, ...grpc.CallOption) (*types.ReplyHash, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqRandHash, ...grpc.CallOption) *types.ReplyHash); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.ReplyHash)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqRandHash, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// QueryTransaction provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) QueryTransaction(ctx context.Context, in *types.ReqHash, opts ...grpc.CallOption) (*types.TransactionDetail, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for QueryTransaction")
	}

	var r0 *types.TransactionDetail
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqHash, ...grpc.CallOption) (*types.TransactionDetail, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqHash, ...grpc.CallOption) *types.TransactionDetail); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.TransactionDetail)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqHash, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ReWriteTx provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) ReWriteTx(ctx context.Context, in *types.ReWriteRawTx, opts ...grpc.CallOption) (*types.UnsignTx, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ReWriteTx")
	}

	var r0 *types.UnsignTx
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReWriteRawTx, ...grpc.CallOption) (*types.UnsignTx, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReWriteRawTx, ...grpc.CallOption) *types.UnsignTx); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.UnsignTx)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.ReWriteRawTx, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SaveSeed provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) SaveSeed(ctx context.Context, in *types.SaveSeedByPw, opts ...grpc.CallOption) (*types.Reply, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SaveSeed")
	}

	var r0 *types.Reply
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.SaveSeedByPw, ...grpc.CallOption) (*types.Reply, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.SaveSeedByPw, ...grpc.CallOption) *types.Reply); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Reply)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.SaveSeedByPw, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SendDelayTransaction provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) SendDelayTransaction(ctx context.Context, in *types.DelayTx, opts ...grpc.CallOption) (*types.Reply, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SendDelayTransaction")
	}

	var r0 *types.Reply
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.DelayTx, ...grpc.CallOption) (*types.Reply, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.DelayTx, ...grpc.CallOption) *types.Reply); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Reply)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.DelayTx, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SendToAddress provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) SendToAddress(ctx context.Context, in *types.ReqWalletSendToAddress, opts ...grpc.CallOption) (*types.ReplyHash, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SendToAddress")
	}

	var r0 *types.ReplyHash
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqWalletSendToAddress, ...grpc.CallOption) (*types.ReplyHash, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqWalletSendToAddress, ...grpc.CallOption) *types.ReplyHash); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.ReplyHash)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqWalletSendToAddress, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SendTransaction provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) SendTransaction(ctx context.Context, in *types.Transaction, opts ...grpc.CallOption) (*types.Reply, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SendTransaction")
	}

	var r0 *types.Reply
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.Transaction, ...grpc.CallOption) (*types.Reply, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.Transaction, ...grpc.CallOption) *types.Reply); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Reply)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.Transaction, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SendTransactionSync provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) SendTransactionSync(ctx context.Context, in *types.Transaction, opts ...grpc.CallOption) (*types.Reply, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SendTransactionSync")
	}

	var r0 *types.Reply
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.Transaction, ...grpc.CallOption) (*types.Reply, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.Transaction, ...grpc.CallOption) *types.Reply); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Reply)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.Transaction, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SendTransactions provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) SendTransactions(ctx context.Context, in *types.Transactions, opts ...grpc.CallOption) (*types.Replies, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SendTransactions")
	}

	var r0 *types.Replies
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.Transactions, ...grpc.CallOption) (*types.Replies, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.Transactions, ...grpc.CallOption) *types.Replies); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Replies)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.Transactions, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SetLabl provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) SetLabl(ctx context.Context, in *types.ReqWalletSetLabel, opts ...grpc.CallOption) (*types.WalletAccount, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SetLabl")
	}

	var r0 *types.WalletAccount
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqWalletSetLabel, ...grpc.CallOption) (*types.WalletAccount, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqWalletSetLabel, ...grpc.CallOption) *types.WalletAccount); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.WalletAccount)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqWalletSetLabel, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SetPasswd provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) SetPasswd(ctx context.Context, in *types.ReqWalletSetPasswd, opts ...grpc.CallOption) (*types.Reply, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SetPasswd")
	}

	var r0 *types.Reply
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqWalletSetPasswd, ...grpc.CallOption) (*types.Reply, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqWalletSetPasswd, ...grpc.CallOption) *types.Reply); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Reply)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqWalletSetPasswd, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SetTxFee provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) SetTxFee(ctx context.Context, in *types.ReqWalletSetFee, opts ...grpc.CallOption) (*types.Reply, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SetTxFee")
	}

	var r0 *types.Reply
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqWalletSetFee, ...grpc.CallOption) (*types.Reply, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqWalletSetFee, ...grpc.CallOption) *types.Reply); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Reply)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqWalletSetFee, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SignRawTx provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) SignRawTx(ctx context.Context, in *types.ReqSignRawTx, opts ...grpc.CallOption) (*types.ReplySignRawTx, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SignRawTx")
	}

	var r0 *types.ReplySignRawTx
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqSignRawTx, ...grpc.CallOption) (*types.ReplySignRawTx, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqSignRawTx, ...grpc.CallOption) *types.ReplySignRawTx); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.ReplySignRawTx)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqSignRawTx, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SignWalletRecoverTx provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) SignWalletRecoverTx(ctx context.Context, in *types.ReqSignWalletRecoverTx, opts ...grpc.CallOption) (*types.ReplySignRawTx, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SignWalletRecoverTx")
	}

	var r0 *types.ReplySignRawTx
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqSignWalletRecoverTx, ...grpc.CallOption) (*types.ReplySignRawTx, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqSignWalletRecoverTx, ...grpc.CallOption) *types.ReplySignRawTx); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.ReplySignRawTx)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqSignWalletRecoverTx, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SubEvent provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) SubEvent(ctx context.Context, in *types.ReqSubscribe, opts ...grpc.CallOption) (types.Chain33_SubEventClient, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SubEvent")
	}

	var r0 types.Chain33_SubEventClient
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqSubscribe, ...grpc.CallOption) (types.Chain33_SubEventClient, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqSubscribe, ...grpc.CallOption) types.Chain33_SubEventClient); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(types.Chain33_SubEventClient)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqSubscribe, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UnLock provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) UnLock(ctx context.Context, in *types.WalletUnLock, opts ...grpc.CallOption) (*types.Reply, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UnLock")
	}

	var r0 *types.Reply
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.WalletUnLock, ...grpc.CallOption) (*types.Reply, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.WalletUnLock, ...grpc.CallOption) *types.Reply); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Reply)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.WalletUnLock, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UnSubEvent provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) UnSubEvent(ctx context.Context, in *types.ReqString, opts ...grpc.CallOption) (*types.Reply, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UnSubEvent")
	}

	var r0 *types.Reply
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqString, ...grpc.CallOption) (*types.Reply, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqString, ...grpc.CallOption) *types.Reply); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Reply)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqString, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Version provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) Version(ctx context.Context, in *types.ReqNil, opts ...grpc.CallOption) (*types.VersionInfo, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Version")
	}

	var r0 *types.VersionInfo
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqNil, ...grpc.CallOption) (*types.VersionInfo, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqNil, ...grpc.CallOption) *types.VersionInfo); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.VersionInfo)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqNil, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WalletTransactionList provides a mock function with given fields: ctx, in, opts
func (_m *Chain33Client) WalletTransactionList(ctx context.Context, in *types.ReqWalletTransactionList, opts ...grpc.CallOption) (*types.WalletTxDetails, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for WalletTransactionList")
	}

	var r0 *types.WalletTxDetails
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqWalletTransactionList, ...grpc.CallOption) (*types.WalletTxDetails, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *types.ReqWalletTransactionList, ...grpc.CallOption) *types.WalletTxDetails); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.WalletTxDetails)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *types.ReqWalletTransactionList, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewChain33Client creates a new instance of Chain33Client. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewChain33Client(t interface {
	mock.TestingT
	Cleanup(func())
}) *Chain33Client {
	mock := &Chain33Client{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
