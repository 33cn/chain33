# paracross 参与多节点共识，发送共识消息给主链

## 平行链交易
 1. 过滤主链里面符合平行链title的平行链交易
 1. 如果平行链交易是交易组，且交易数为2，若另一个是主链交易，只有主链交易是ExecOk，平行链tx才打包， 若另一个也是平行链，打包
 1. 平行链发给主链的交易执行结果位图，只包含打包了的平行链tx，若是跨链交易且因主链执行失败而未打包进区块的平行链交易，不包含在位图内。

## 初始启动
 1. 共识tick（16s）会定期通过grpc获取当前共识height
    * 如果各节点都是创世启动，则返回-1，则进入sync环节，发起共识消息
    * 如果是本节点重启或一个全新节点，则主动同步其他节点数据，在同步过程中，不获取共识数据，也不发送共识消息，同步结束后，获取当前共识高度，在当前
      共识高度之前的区块，不发送共识,从当前共识节点开始发送共识消息,进入sync状态，参与共识

## 新节点增加（包括空块）
   维护了三个slice， notification，sending,(finished暂时不需要), 
   notification: 新的tx追加到notification里面，如果因为比如共识一直不成功，节点重连，导致本节点和主链节点都落后很多，需要大量同步，这样
   notification slice就会缓存很多数据，缓存太大容易让系统内存崩溃，所有达到比如100时候就要阻塞从主链接受数据。
   sending: 定时器轮询到notification有数据要发，小于20个msg转移到sending来发送。
   sending的tx有可能是一个块的交易，也可能是多个块的交易组，sending的tx成功被打包到主链且执行成功才算正常上链，若在两个新块里面没有上链会重发当前
   的交易，一直当前的上链才会发后面的tx，如果发生了分叉回滚且分叉节点在sending tx里面，会取消发送。
   finished：打包成功的tx会移到finish里面。finish的最初目的主要是考虑未达成共识，且本节点没有发交易，需要重发，所有在finish里面放了缓存，
   但是考虑到finish的交易都是被主链上链了的交易，也就是本节点已经发送过了的交易，应该不需要重新发的场景。如果完成了的交易分叉了，应该会有同样高度
   的新交易发送而不会停止。所有暂时不需要
   *异常场景：
   1. 如果通过grpc发送失败，通知一个channel重发

## 分叉，节点回滚
 1. delete的block高度先在notification里面查找，如果找到，意味着还没send，直接删除，如果notification没找到，在sending里面找，如果找到了，
    取消所有sending的tx，把本tx删除后把其他的恢复到notification里面，重新发送

## 普通执行
 1.维护一个2s的tick，定时检查notification里面有没有数据，当前有没有正在发送的tx，如果当前tx已经上链，且notification有数据，会把notification
   数据转移到sending里面维持发送
 1.维护一个20s的tick，定时从主链检查当前共识的高度，移除本节点低于共识高度的tx。如果主链正在同步，则等同步完成后再检查高度。
 1.维护一个主链block add的channel，如果收到主链block，检查是否当前的交易在block里面且执行成功，如果执行失败或pack，都不算上链，都需要重发。
   成功上链则移除当前sending数组到finish里面

## 签名
 1. 根据配置的地址从wallet导出私钥，利用私钥在平行链共识签名。如果钱包处于锁定状态，钱包侧需要设置一个错误码提示用户，平行链侧会持续每隔2s发送查询，
    直到解锁钱包，查询成功，清除错误码。

## 失败场景
 1. grpc链路失败，会1s超时重发，一直失败一直发，如果期间tx两个块没发现重发，重发的tx也会更新为新的tx，为了防止mempool当做重复交易，tx的nonce会变
 1. 交易费不够，交易失败
 1. 平行链已经发送commit msg，主链回滚，主链找不到commit msg对应的块，平行链重复发送，直到平行链回滚把sending取消
 1. 平行链主链分叉，主链执行其他平行链发来的交易将失败，自己的会成功，主链分叉回滚后恢复
 1. 主链都正常，平行链从创始开始就没有达成共识，平行链问题，100个块之后平行链会停止产生区块
 1. 主链正常，某平行链自己计算有问题，不能和别人产生共识，此平行链提交的交易会失败，但仍然过滤交易产生区块，不影响共识，如果成功的不足2/3节点，共识
    将停止不走，各平行链自己仍产生区块，平行链自身问题，需要debug
 1. 平行链全部在某一高度全部崩溃，共识高度落后区块高度，待节点重启后，共识可能有空洞，需要避免.也就是以共识高度为起点，小于共识高度的不需要发，
    大于共识高度，小于正在发送的高度的共识，需要从数据库获取出来重新发出去
 1. 因为某种原因，比如超过2/3节点崩溃或者数据不一致，系统在某一个高度没有产生共识，共识系统会把已收到的交易记下，即便记录已经达到共识但是因为共识高度
    并不是连续的，或者说因为共识空洞，后面来的共识也只是记录，不会触发done，只有和数据库共识连续的共识commit才能触发done，所以一旦产生空洞，需要
    从空洞开始处连续发送后续交易，而不能只发送空洞的共识commit       

## 发送失败策略 
 1. 当前策略是是要么单个交易，要么一个交易组发送共识消息，要么全部成功，要么全部失败，如果失败，也就是交易在新块里面找不到，超过2个块会重发当前
    sending里面的交易，新的共识消息会一直等待，如果当前sending的tx一直没有进入主块，后面高度的共识消息将一直得不到发送。消息失败的场景除了链路
    失败之外基本就是分叉导致的，当前策略目前失败场景看没问题。
 1. 另一种可能的策略是有新来的交易和当前的一起发，这样最好是每个高度一个交易，而不能交易组，分别检查交易入链情况，如果没入链的交易重发，这种策略场景
    有些复杂，而且共识交易如果高的共识成功，低的失败了，意义也不大，所以当前采取的第一种发送策略   
 
## 测试场景
 1. 主节点和平行链节点在一个docker里面启动，平行链节点晚于主节点120s启动，基本上是主节点8个高度时候
 1. 6个节点，4个平行链节点，两个出空块间隔是4，另两个是3，不能达成共识
 1. 6个节点，4个平行链节点, 三个出空块间隔4，一个3，可以达成共识
 1. 6个节点，4个平行链节点，三个先启动，第四个过10分钟后启动，启动后会同步其他节点数据，从当前共识节点开始发送 
 1. 6个节点，4个平行链节点，三个先启动，第四个过10分钟后启动，启动后同步其他节点数据，从当前共识高度发送，停止10分钟，再启动，同步以前数据，然后再发送    
 1. 6个节点，4个平行链节点，三三分组，其中a组有三个平行链节点，b组只有一个，分叉测试，先停b组，然后停a组起b组，然后起a组一起挖矿，b组在单独挖矿时候，
    平行链无法共识，停留在当前高度，待a组启动后，b组分叉节点回滚，重新达成共识，b组平行链也共识成功   