// Code generated by mockery v1.0.0. DO NOT EDIT.

package mocks

import (
	client "github.com/33cn/chain33/client"
	common "github.com/33cn/chain33/wallet/common"

	crypto "github.com/33cn/chain33/common/crypto"

	db "github.com/33cn/chain33/common/db"

	mock "github.com/stretchr/testify/mock"

	rand "math/rand"

	sync "sync"

	types "github.com/33cn/chain33/types"
)

// WalletOperate is an autogenerated mock type for the WalletOperate type
type WalletOperate struct {
	mock.Mock
}

// AddrInWallet provides a mock function with given fields: addr
func (_m *WalletOperate) AddrInWallet(addr string) bool {
	ret := _m.Called(addr)

	var r0 bool
	if rf, ok := ret.Get(0).(func(string) bool); ok {
		r0 = rf(addr)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// CheckWalletStatus provides a mock function with given fields:
func (_m *WalletOperate) CheckWalletStatus() (bool, error) {
	ret := _m.Called()

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAPI provides a mock function with given fields:
func (_m *WalletOperate) GetAPI() client.QueueProtocolAPI {
	ret := _m.Called()

	var r0 client.QueueProtocolAPI
	if rf, ok := ret.Get(0).(func() client.QueueProtocolAPI); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(client.QueueProtocolAPI)
		}
	}

	return r0
}

// GetAllPrivKeys provides a mock function with given fields:
func (_m *WalletOperate) GetAllPrivKeys() ([]crypto.PrivKey, error) {
	ret := _m.Called()

	var r0 []crypto.PrivKey
	if rf, ok := ret.Get(0).(func() []crypto.PrivKey); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]crypto.PrivKey)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBalance provides a mock function with given fields: addr, execer
func (_m *WalletOperate) GetBalance(addr string, execer string) (*types.Account, error) {
	ret := _m.Called(addr, execer)

	var r0 *types.Account
	if rf, ok := ret.Get(0).(func(string, string) *types.Account); ok {
		r0 = rf(addr, execer)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Account)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string) error); ok {
		r1 = rf(addr, execer)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBlockHeight provides a mock function with given fields:
func (_m *WalletOperate) GetBlockHeight() int64 {
	ret := _m.Called()

	var r0 int64
	if rf, ok := ret.Get(0).(func() int64); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(int64)
	}

	return r0
}

// GetConfig provides a mock function with given fields:
func (_m *WalletOperate) GetConfig() *types.Wallet {
	ret := _m.Called()

	var r0 *types.Wallet
	if rf, ok := ret.Get(0).(func() *types.Wallet); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Wallet)
		}
	}

	return r0
}

// GetDBStore provides a mock function with given fields:
func (_m *WalletOperate) GetDBStore() db.DB {
	ret := _m.Called()

	var r0 db.DB
	if rf, ok := ret.Get(0).(func() db.DB); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(db.DB)
		}
	}

	return r0
}

// GetLastHeader provides a mock function with given fields:
func (_m *WalletOperate) GetLastHeader() *types.Header {
	ret := _m.Called()

	var r0 *types.Header
	if rf, ok := ret.Get(0).(func() *types.Header); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Header)
		}
	}

	return r0
}

// GetMutex provides a mock function with given fields:
func (_m *WalletOperate) GetMutex() *sync.Mutex {
	ret := _m.Called()

	var r0 *sync.Mutex
	if rf, ok := ret.Get(0).(func() *sync.Mutex); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*sync.Mutex)
		}
	}

	return r0
}

// GetPassword provides a mock function with given fields:
func (_m *WalletOperate) GetPassword() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// GetPrivKeyByAddr provides a mock function with given fields: addr
func (_m *WalletOperate) GetPrivKeyByAddr(addr string) (crypto.PrivKey, error) {
	ret := _m.Called(addr)

	var r0 crypto.PrivKey
	if rf, ok := ret.Get(0).(func(string) crypto.PrivKey); ok {
		r0 = rf(addr)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(crypto.PrivKey)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(addr)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetRandom provides a mock function with given fields:
func (_m *WalletOperate) GetRandom() *rand.Rand {
	ret := _m.Called()

	var r0 *rand.Rand
	if rf, ok := ret.Get(0).(func() *rand.Rand); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rand.Rand)
		}
	}

	return r0
}

// GetSignType provides a mock function with given fields:
func (_m *WalletOperate) GetSignType() int {
	ret := _m.Called()

	var r0 int
	if rf, ok := ret.Get(0).(func() int); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(int)
	}

	return r0
}

// GetTxDetailByHashs provides a mock function with given fields: ReqHashes
func (_m *WalletOperate) GetTxDetailByHashs(ReqHashes *types.ReqHashes) {
	_m.Called(ReqHashes)
}

// GetWaitGroup provides a mock function with given fields:
func (_m *WalletOperate) GetWaitGroup() *sync.WaitGroup {
	ret := _m.Called()

	var r0 *sync.WaitGroup
	if rf, ok := ret.Get(0).(func() *sync.WaitGroup); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*sync.WaitGroup)
		}
	}

	return r0
}

// GetWalletAccounts provides a mock function with given fields:
func (_m *WalletOperate) GetWalletAccounts() ([]*types.WalletAccountStore, error) {
	ret := _m.Called()

	var r0 []*types.WalletAccountStore
	if rf, ok := ret.Get(0).(func() []*types.WalletAccountStore); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*types.WalletAccountStore)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetWalletDone provides a mock function with given fields:
func (_m *WalletOperate) GetWalletDone() chan struct{} {
	ret := _m.Called()

	var r0 chan struct{}
	if rf, ok := ret.Get(0).(func() chan struct{}); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(chan struct{})
		}
	}

	return r0
}

// IsCaughtUp provides a mock function with given fields:
func (_m *WalletOperate) IsCaughtUp() bool {
	ret := _m.Called()

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// IsClose provides a mock function with given fields:
func (_m *WalletOperate) IsClose() bool {
	ret := _m.Called()

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// IsWalletLocked provides a mock function with given fields:
func (_m *WalletOperate) IsWalletLocked() bool {
	ret := _m.Called()

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// Nonce provides a mock function with given fields:
func (_m *WalletOperate) Nonce() int64 {
	ret := _m.Called()

	var r0 int64
	if rf, ok := ret.Get(0).(func() int64); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(int64)
	}

	return r0
}

// RegisterMineStatusReporter provides a mock function with given fields: reporter
func (_m *WalletOperate) RegisterMineStatusReporter(reporter common.MineStatusReport) error {
	ret := _m.Called(reporter)

	var r0 error
	if rf, ok := ret.Get(0).(func(common.MineStatusReport) error); ok {
		r0 = rf(reporter)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SendToAddress provides a mock function with given fields: priv, addrto, amount, note, Istoken, tokenSymbol
func (_m *WalletOperate) SendToAddress(priv crypto.PrivKey, addrto string, amount int64, note string, Istoken bool, tokenSymbol string) (*types.ReplyHash, error) {
	ret := _m.Called(priv, addrto, amount, note, Istoken, tokenSymbol)

	var r0 *types.ReplyHash
	if rf, ok := ret.Get(0).(func(crypto.PrivKey, string, int64, string, bool, string) *types.ReplyHash); ok {
		r0 = rf(priv, addrto, amount, note, Istoken, tokenSymbol)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.ReplyHash)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(crypto.PrivKey, string, int64, string, bool, string) error); ok {
		r1 = rf(priv, addrto, amount, note, Istoken, tokenSymbol)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SendTransaction provides a mock function with given fields: payload, execer, priv, to
func (_m *WalletOperate) SendTransaction(payload types.Message, execer []byte, priv crypto.PrivKey, to string) ([]byte, error) {
	ret := _m.Called(payload, execer, priv, to)

	var r0 []byte
	if rf, ok := ret.Get(0).(func(types.Message, []byte, crypto.PrivKey, string) []byte); ok {
		r0 = rf(payload, execer, priv, to)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(types.Message, []byte, crypto.PrivKey, string) error); ok {
		r1 = rf(payload, execer, priv, to)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WaitTx provides a mock function with given fields: hash
func (_m *WalletOperate) WaitTx(hash []byte) *types.TransactionDetail {
	ret := _m.Called(hash)

	var r0 *types.TransactionDetail
	if rf, ok := ret.Get(0).(func([]byte) *types.TransactionDetail); ok {
		r0 = rf(hash)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.TransactionDetail)
		}
	}

	return r0
}

// WaitTxs provides a mock function with given fields: hashes
func (_m *WalletOperate) WaitTxs(hashes [][]byte) []*types.TransactionDetail {
	ret := _m.Called(hashes)

	var r0 []*types.TransactionDetail
	if rf, ok := ret.Get(0).(func([][]byte) []*types.TransactionDetail); ok {
		r0 = rf(hashes)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*types.TransactionDetail)
		}
	}

	return r0
}
